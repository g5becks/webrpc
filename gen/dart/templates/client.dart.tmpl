{{define "client"}}

{{if .Services}}
// ***********************************************************************
// WEBRPC-DART SERVICE CLIENTS.
// ***********************************************************************

String _removeSlash(String host) => host.endsWith('/')
? host.replaceRange(host.length - 1, host.length, '')
: host;

{{range .Services}}
class {{.Name}} {
  final String host;
  String _srvcPath = '/rpc/{{.Name}}/';
  {{.Name}}({
    this.host = 'localhost',
  }) {
      _srvcPath = '${_removeSlash(host)}/rpc/{{.Name}}/';
  } 

  Future<http.Response> _makeRequest(String route,
      {dynamic json = "{}", Map<String, String> headers,}) {
    final path = '$_srvcPath/$route';
    return http.post(path,
        headers: {
          ...?headers,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: json);
  }

  _RpcErr _getErr(http.Response r) {
    try {
      return _RpcErr.fromJson(jsonDecode(r.body)); 
    } on Exception catch (_) {
      return _RpcErr.unknown;
    }
  }
 
  {{range .Methods}}
  {{. | methodOutputs}} {{.Name | methodName}}({
  {{if .Inputs}}
  {{- range .Inputs}}
  {{- if not .Optional}}@required {{.Type | fieldType}} {{.Name}},
  {{- end -}} {{/* end of if not .Optional */}}
  {{- end -}} {{/* end of range .Inputs */}}
  {{- range .Inputs}}
  {{if .Optional}}
  {{.Type | fieldType}} {{.Name}},
  {{- end -}} {{/* end of if not .Optional */}}
{{- end}} {{/* end of range .Inputs */}}
{{- end}} {{/* end of if .Inputs */}}
  Map<String, String> headers,
  }) async{{if .Outputs | len}}*{{end}} {
    {{if .Outputs | len}}
    const num = 0;
    while (num == 0) {
      yield const {{. | methodArgumentOutputClassName}}.pending();
      try {
        {{- if .Inputs | len}} {{/* if method has args */}}
          final _{{. | methodArgumentInputClassName}} args = _{{. | methodArgumentInputClassName}}({{- range .Inputs}}{{.Name}}:{{.Name}},{{- end}});
          {{end}} {{/* end of if .Inputs */}}
          final http.Response response = await _makeRequest(
            '{{.Name}}',
            json: jsonEncode({{- if .Inputs | len}} {{/* if method has args */}}args.toJson(){{else}} "{}" {{end}} {{/* end of if .Inputs */}}),
            headers: headers,
          );

          if (!_nonErrorcodes.contains(response.statusCode)) {
            final _RpcErr err = _getErr(response);
            yield {{. | methodArgumentOutputClassName}}.failed(
                reason: err.message,
                statusCode: err.httpErr.code,
                );
                break;
          }
          yield {{. | methodArgumentOutputClassName}}.fromJson(
              jsonDecode(response.body,),);
          break;    
      } on Exception catch (e, stackTrace) {
        yield {{. | methodArgumentOutputClassName}}.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }  {{end}} {{/* end of if .Outputs */}}
  }
  {{end}} {{/* end of range .Methods */}}

}
{{end}} {{/* end of range .Services */}}


{{end}} {{/* end of if .Services */}}
{{end}} {{/* end of top level Define */}}
