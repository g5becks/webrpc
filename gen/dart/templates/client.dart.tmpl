{{define "client"}}

{{if .Services}}

// *********************************************************************
// Service Interfaces. Useful for testing purposes.
// *********************************************************************
{{range .Services}}
abstract class {{.Name}}Rpc {
  {{range .Methods}}
  {{. | methodOutputsClient}} {{.Name | methodName}}({
  {{if .Inputs}}
  {{- range .Inputs}}
  {{- if not .Optional}}@required {{.Type | fieldType}} {{.Name}},
  {{- end -}} {{/* end of if not .Optional */}}
  {{- end -}} {{/* end of range .Inputs */}}
  {{- range .Inputs}}
  {{if .Optional}}
  {{.Type | fieldType}} {{.Name}},
  {{- end -}} {{/* end of if not .Optional */}}
{{- end}} {{/* end of range .Inputs */}}
{{- end}} {{/* end of if .Inputs */}}
  Map<String, String> headers,
  });
  {{end}} {{/* end of range .Methods */}}
}
{{end}} {{/* end of range .Services */}}
// *********************************************************************
// RpcResponse TYPE.
// *********************************************************************

// This class provides type safe access to the state of an RpcRequest 
// and it's Response data. Can be used easily with Bloc. For more info See https://www.azavea.com/blog/2019/12/12/modeling-state-with-typescript/
// See https://pub.dev/packages/freezed to learn how to use this type.
@freezed
abstract class RpcResponse<T> with _$RpcResponse<T> {
  factory RpcResponse.ok({@required T data,}) = _RpcResponseOk<T>;
  const factory RpcResponse.err({@required String reason, @required int statusCode, String stackTrace,}) = _RpcResonseErr<T>;
  const factory RpcResponse.loading() = _RpcResponseLoading<T>;
}
// ***********************************************************************
// WEBRPC-DART SERVICE CLIENTS.
// ***********************************************************************

{{range .Services}}
class {{.Name}} implements {{.Name}}Rpc {
  final String host;
  String _srvcPath = '/rpc/{{.Name}}/';
  {{.Name}}({
    this.host = 'localhost',
  }) {
      _srvcPath = '${_removeSlash(host)}/rpc/{{.Name}}/';
  } 

  Future<http.Response> _makeRequest(String route,
      {dynamic json = "{}", Map<String, String> headers,}) {
    final path = '$_srvcPath/$route';
    return http.post(path,
        headers: {
          ...?headers,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(json),);
  }

  _RpcErr _getErr(http.Response r) {
    try {
      return _RpcErr.fromJson(jsonDecode(r.body)); 
    } on Exception catch (_) {
      return _RpcErr.unknown;
    }
  }
 
  {{range .Methods}}
  @override
  {{. | methodOutputsClient}} {{.Name | methodName}}({
  {{if .Inputs}}
  {{- range .Inputs}}
  {{- if not .Optional}}@required {{.Type | fieldType}} {{.Name}},
  {{- end -}} {{/* end of if not .Optional */}}
  {{- end -}} {{/* end of range .Inputs */}}
  {{- range .Inputs}}
  {{if .Optional}}
  {{.Type | fieldType}} {{.Name}},
  {{- end -}} {{/* end of if not .Optional */}}
{{- end}} {{/* end of range .Inputs */}}
{{- end}} {{/* end of if .Inputs */}}
  Map<String, String> headers,
  }) async* {
      yield const RpcResponse.loading();
      try {
        {{- if .Inputs | len}} {{/* if method has args */}}
          final _{{. | methodArgumentInputClassName}} args = _{{. | methodArgumentInputClassName}}({{- range .Inputs}}{{.Name}}:{{.Name}},{{- end}});
          {{end}} {{/* end of if .Inputs */}}
          final http.Response response = await _makeRequest(
            '{{.Name}}',
            {{- if .Inputs | len}}json: jsonEncode(args.toJson(),),{{end}}
            headers: headers,
          );

          if (!_nonErrorcodes.contains(response.statusCode)) {
            final _RpcErr err = _getErr(response);
            yield RpcResponse.err(
                reason: err.message,
                statusCode: err.httpErr.code,
                );
          }
          yield RpcResponse.ok(data:{{if .Outputs | len}} {{. | methodArgumentOutputClassName}}.fromJson(
              jsonDecode(response.body,),),{{else}} response.statusCode,{{end}});
      } on Exception catch (e, stackTrace) {
        yield RpcResponse.err(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
    } 
 
  }
  {{end}} {{/* end of range .Methods */}}

}
{{end}} {{/* end of range .Services */}}


{{end}} {{/* end of if .Services */}}
{{end}} {{/* end of top level Define */}}
