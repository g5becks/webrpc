{{define "server"}}
{{- if .Services}}
// *********************************************************************
// SERVICE INTERFACES.
// *********************************************************************
{{range .Services -}}
// TODO implement {{.Name}}.
abstract class {{.Name}} {
  {{- range .Methods}}
  {{. | methodOutputs}} {{.Name | methodName}}({{. | serverMethodInputs}});
  {{- end}}
}
{{end}}  {{/* end of range .Services for INTERFACES */}}

// *********************************************************************
// SERVER IMPLEMENTATION.
// *********************************************************************
class WebRpcServer {
  // For Google Cloud Run, set _hostname to '0.0.0.0'.
  String _hostname;
  // Provide a {Logger} implementation to log failed requests.
  RpcLogger _log;
  // Provide a preconfigured shelf.Pipeline with desired middleware.
  Set<shelf.Middleware> _middleware;
{{- range .Services}}
  final {{.Name}} {{.Name | serviceImplName}};
{{- end}}  
  WebRpcServer(
    { {{ range .Services }}@required this.{{.Name | serviceImplName}},
      {{end -}}
      RpcLogger log,
      String hostName = 'localhost',
      List<shelf.Middleware> middleware}) {
      _hostname = hostName;
      _log = log ?? _rpcLogger;
      _middleware = middleware?.toSet() ?? [shelf.logRequests()];
  }

  bool _jsonFriendly(shelf.Request r) =>
      r.headers['Content-Type'].contains('application/json') &&
      r.headers['Accept'].contains('application/json');  

  FutureOr<shelf.Response> _requestHandler(shelf.Request r) async {
    final route = r.url.path;
    if (r.method != 'POST') {
      final info =
          'unsupported method: ${r.method}, (only POST is allowed. path: $route';
      _log.info(info);
      return rpcResp.BadRoute(route, msg: info);
    }

    if (!_jsonFriendly(r)) {
      final info =
          'unexpected Content-Type: ${r.headers['Content-Type']} or Accept: ${r.headers['Accept']}. path: $route';
      _log.info(info);
      return rpcResp.BadRoute(route, msg: info);
    }

    switch (r.url.path) {
      {{ range .Services }}
      {{$name := .Name}}
      {{- range .Methods}}
      case '/rpc/{{$name}}/{{.Name}}': {
         return await _handle{{$name}}{{.Name}}(r);
      }
      break;
      {{end -}} {{/* end of range .Methods */}}
      {{end -}} {{/* end of range .Services */}}
      default:
        {
          final info = 'no handler for path: $route';
          _log.info(info);
          return rpcResp.BadRoute(route, msg: info);
        }
        break;
    }
  }
  {{- range .Services}}
  {{$name := .Name}}
  {{- range .Methods}}
  FutureOr<shelf.Response> _handle{{$name}}{{.Name}}(shelf.Request r) async {
    
  }
  {{end}}{{/* end of range .Methods */}}
  {{- end -}} {{/* end of range .Services for Methods */}}
  FutureOr<void> run() async {}

}
{{end}} {{/* end of if .Services */}}
{{end}} {{/* end of top level define */}}
