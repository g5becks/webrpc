{{define "server"}}
{{- if .Services}}
// *********************************************************************
// SERVICE INTERFACES.
// *********************************************************************
{{range .Services -}}
// TODO implement {{.Name}}.
abstract class {{.Name}} {
  {{- range .Methods}}
  {{. | methodOutputs}} {{.Name | methodName}}({{if .Inputs}} {  
  {{- range .Inputs}}
  {{- if not .Optional}}@required {{.Type | fieldType}} {{.Name}},
  {{- end -}} {{/* end of if not .Optional */}}
  {{- end -}} {{/* end of range .Inputs */}}
  {{- range .Inputs}}
  {{if .Optional}}
  {{.Type | fieldType}} {{.Name}},
  {{- end -}}
{{- end}}
  } {{- end}});
  {{- end}}
}
{{end}}  {{/* end of range .Services for INTERFACES */}}

// *********************************************************************
// SERVER IMPLEMENTATION.
// *********************************************************************

typedef HandlerMapFn = Map<String, shelf.Handler> Function();

// If for some reason you do not want to use the provider WebRpc server /// below, you can simple create and instance of it, and instead of
// calling the .serve method, pass the results of the .handlerMapFn
// getter as a list to this function. This can be useful if you are
// adding a webRpc server to an existing shelf server, or if you have
// other servers that were created by webRpc in the same project.
/// Returns the lesser of two numbers.
///
/// ```dart
/// final WebRpcServer server1 = WebRpcServer(// service implementations);
/// final shelf.Handler handler = handlerFromServers([service1, service2, ...]);
/// ```
///
shelf.Handler handlerFromServers(List<HandlerMapFn> handlerFns,
    {RpcLogger logger}) {
  logger ??= _rpcLogger;
  final fnSet = handlerFns?.toSet();
  final Map<String, shelf.Handler> handlers = {
    for (final fn in fnSet) ...?fn()
  };
  return const shelf.Pipeline()
      .addMiddleware(_nonJsonMddlwr)
      .addMiddleware(_notPostMddlwr)
      .addMiddleware(shelf.logRequests(
        logger: (msg, isErr) => isErr ? logger.shout(msg) : logger.info(msg),
      ),)
      .addHandler((shelf.Request r) {
    final handler = handlers[r.requestedUri.toString()] ?? _badRouteHandler;
    return handler(r);
  });
}
class WebRpcServer {
  // Pass the results of this getter to the handlerFromServers function 
  // in to get a shelf.Handler if you would like to configure your
  // server manully outside of this class.  
  HandlerMapFn get handlerMapFn {
    final Map<String, shelf.Handler> _handlersMap = {};
    _handlersMap.addAll({
      {{ range .Services }}
      {{$name := .Name}}
      {{- range .Methods}}
      '/rpc/{{$name}}/{{.Name}}':this._handle{{$name}}{{.Name}}, 
      {{end}}
      {{end}}
    });
    return () => _handlersMap;
  }
  // For Google Cloud Run, set _hostname to '0.0.0.0'.
  String _hostname;
  // Provide a {Logger} implementation to log exceptions.
  RpcLogger _log;
  // Provide a preconfigured shelf.Pipeline with desired middleware.
  Set<shelf.Middleware> _middleware;
  // Shelf Pipeline.
  final shelf.Pipeline _pipeline = const shelf.Pipeline();
  // A reference to the http server.
  HttpServer _server;
  // Expose internal server for user customization.
  HttpServer get server => _server;
{{- range .Services}}
  final {{.Name}} {{.Name | serviceImplName}};
{{- end}}  
  WebRpcServer(
    { {{ range .Services }}@required this.{{.Name | serviceImplName}},
      {{end -}}
      RpcLogger logger,
      String hostName = 'localhost',
      List<shelf.Middleware> middleware,}) {
      _hostname = hostName;
      _log = logger ?? _rpcLogger;
      _middleware = {
      ...?middleware?.toSet(),
      shelf.logRequests(
        logger: (msg, isErr) => isErr ? _log.shout(msg) : _log.info(msg),
      ),
      _nonJsonMddlwr,
      _notPostMddlwr,
    };
  }


  FutureOr<shelf.Response> _requestHandler(shelf.Request r) async {
    final route = r.requestedUri.toString();
    switch (route) {
      {{ range .Services }}
      {{$name := .Name}}
      {{- range .Methods}}
      case '/rpc/{{$name}}/{{.Name}}': {
         return _handle{{$name}}{{.Name}}(r);
      }
      break;
      {{end -}} {{/* end of range .Methods */}}
      {{end -}} {{/* end of range .Services */}}
      default:
        {
          return _badRouteHandler(r, logger: _log,);
        }
        break;
    }
  }
  {{- range .Services}}
  {{$name := .Name}}
  {{- range .Methods}}
  FutureOr<shelf.Response> _handle{{$name}}{{.Name}}(shelf.Request r,) async {
    try {
      // Attempt to call service method.
    {{- if .Inputs|len }}
      final json = await r.readAsString();
      final _{{. | methodArgumentInputClassName}} args = _{{. | methodArgumentInputClassName}}.fromJson(jsonDecode(json),);
      {{ if .Outputs | len -}}
      final {{. | methodArgumentOutputClassName}} result = await {{$name | serviceImplName}}.{{.Name | methodName}}({{- range .Inputs}}{{.Name}}:args.{{.Name}},{{- end}});  
      return _rpcResp.Ok(json: jsonEncode(result.toJson(),),);
      {{else}}
      await {{$name | serviceImplName}}.{{.Name | methodName}}({{- range .Inputs}}{{.Name}}:args.{{.Name}},{{- end}});
      return _rpcResp.Ok();
      {{- end -}} {{/* end if .Outputs */}}
    {{else}}
      {{ if .Outputs | len -}}
      final {{. | methodArgumentOutputClassName}} result = await {{$name | serviceImplName}}.{{.Name | methodName}}();  
      return _rpcResp.Ok(json: jsonEncode(result.toJson(),),);
      {{else}}
      await {{$name | serviceImplName}}.{{.Name | methodName}}();
      return _rpcResp.Ok();
      {{- end -}}
    {{- end -}} {{/* end if .Inputs */}}
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace,);
      return _rpcResp.Fail('/rpc/{{$name}}/{{.Name}}');
    }
    // Catch all other exceptions. 
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace,);
      return _rpcResp.Fail('/rpc/{{$name}}/{{.Name}}');
    }
  }
  {{end}}{{/* end of range .Methods */}}
  {{- end -}} {{/* end of range .Services for Methods */}}
  ArgResults _parseArgs(List<String> args) {
  final parser = ArgParser()..addOption('port', abbr: 'p');
  try {
    return parser.parse(args);
  } on ArgParserException catch (e, stackTrace) {
    _logExc(_log, e, null, stackTrace,);
    print('arg parsing error occured: $e');
    rethrow;
  }
}

  // For Google Cloud Run, we respect the PORT environment variable
  int _getPort(ArgResults args) =>
      int.tryParse(args['port'] ?? Platform.environment['PORT'] ?? '8080',);

  void _configurePipeline() =>
    _middleware.forEach((mddlwr) => _pipeline.addMiddleware(mddlwr),);

  Future<void> serve(List<String> args,
      {SecurityContext securityContext,
      int backlog,
      bool shared = false}) async {
    final result = _parseArgs(args);
    final port = _getPort(result);

    if (port == null) {
      stdout.writeln(
          'Could not parse port value "${port.toString()}" into a number.');
      // 64: command line usage error
      exitCode = 64;
      return;
    }

    _configurePipeline();
    final handler = _pipeline.addHandler(_requestHandler);
    _server = await io.serve(handler, _hostname, port,
        securityContext: securityContext, backlog: backlog, shared: shared);
    print('Serving at http://${_server.address.host}:${_server.port}');
  }


}
{{end}} {{/* end of if .Services */}}
{{end}} {{/* end of top level define */}}
