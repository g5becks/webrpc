import 'dart:async';

import 'package:meta/meta.dart';
import 'package:freezed_annotation/freezed_annotation.dart';


import 'package:shelf_router/shelf_router.dart';
import 'package:shelf/shelf.dart' as shelf;
import 'package:shelf/shelf_io.dart' as io;
import 'package:logging/logging.dart';


// example v0.0.1 b22daedd801edc99b28353f3d7912365ee85ad73
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/dart
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
String webRPCVersion()  {
  return "v1";
}

// Schema version of your RIDL schema
String WebRPCSchemaVersion() {
  return "v0.0.1";
}

// Schema hash generated from your RIDL schema
String WebRPCSchemaHash() {
  return "b22daedd801edc99b28353f3d7912365ee85ad73";
}


// **********************************************************************
// MESSAGE TYPES.
// **********************************************************************
@freezed
abstract class Kind with _$Kind {
  const factory Kind.user() = USER;
  const factory Kind.admin() = ADMIN;
  factory Kind.fromJson(Map<String, dynamic> json) => _$KindFromJson(json);
}

@freezed
abstract class Empty with _$Empty {
  const factory Empty() = _Empty;
  factory Empty.fromJson(Map<String, dynamic> json) => _$EmptyFromJson(json);
}
@freezed
abstract class User with _$User {
  const factory User({
     @required int id,
    @Jsonkey(name: 'USERNAME') @required String username,
     @required String role,
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}
@freezed
abstract class SearchFilter with _$SearchFilter {
  const factory SearchFilter({
     @required String q,
  }) = _SearchFilter;
  factory SearchFilter.fromJson(Map<String, dynamic> json) => _$SearchFilterFromJson(json);
}
@freezed
abstract class Version with _$Version {
  const factory Version({
     @required String webrpcVersion,
     @required String schemaVersion,
     @required String schemaHash,
  }) = _Version;
  factory Version.fromJson(Map<String, dynamic> json) => _$VersionFromJson(json);
}
@freezed
abstract class ComplexType with _$ComplexType {
  const factory ComplexType({
     @required Map<String, dynamic> meta,
     @required Map<String, Map<String, int>> metaNestedExample,
     @required List<String> namesList,
     @required List<int> numsList,
     @required List<List<String>> doubleArray,
     @required List<User> listOfUsers,
     @required Map<String, User> mapOfUsers,
     @required User user,
    List<Map<String, int>> listOfMaps,
  }) = _ComplexType;
  factory ComplexType.fromJson(Map<String, dynamic> json) => _$ComplexTypeFromJson(json);
}


// *********************************************************************
// METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class GetUserArgs with _$GetUserArgs {
  const factory GetUserArgs ({@required Map<String, String> header,@required int userID,
  
  
  }) = _GetUserArgs;
  factory GetUserArgs.fromJson(Map<String, dynamic> json) => _$GetUserArgsFromJson(json);
}
@freezed
abstract class FindUserArgs with _$FindUserArgs {
  const factory FindUserArgs ({@required SearchFilter s,
  
  }) = _FindUserArgs;
  factory FindUserArgs.fromJson(Map<String, dynamic> json) => _$FindUserArgsFromJson(json);
}

// *********************************************************************
// METHOD RETURN TYPES.
// *********************************************************************
 

@freezed
abstract class StatusReturn with _$StatusReturn {
  const factory StatusReturn({@required bool status,}) = _StatusReturn;
  factory StatusReturn.fromJson(Map<String, dynamic> json) => _$StatusReturnFromJson(json);
}
 

@freezed
abstract class VersionReturn with _$VersionReturn {
  const factory VersionReturn({@required Version version,}) = _VersionReturn;
  factory VersionReturn.fromJson(Map<String, dynamic> json) => _$VersionReturnFromJson(json);
}
 

@freezed
abstract class GetUserReturn with _$GetUserReturn {
  const factory GetUserReturn({@required int code,@required User user,}) = _GetUserReturn;
  factory GetUserReturn.fromJson(Map<String, dynamic> json) => _$GetUserReturnFromJson(json);
}
 

@freezed
abstract class FindUserReturn with _$FindUserReturn {
  const factory FindUserReturn({@required String name,@required User user,}) = _FindUserReturn;
  factory FindUserReturn.fromJson(Map<String, dynamic> json) => _$FindUserReturnFromJson(json);
}
 




  

// *********************************************************************
// SERVICE INTERFACES.
// *********************************************************************
abstract class ExampleService {
  FutureOr<void> ping();
  FutureOr<StatusReturn> status();
  FutureOr<VersionReturn> version();
  FutureOr<GetUserReturn> getUser({@required GetUserArgs args});
  FutureOr<FindUserReturn> findUser({@required FindUserArgs args});
}

// *********************************************************************
// SERVER IMPLEMENTATION.
// *********************************************************************

// For Google Cloud Run, set _hostname to '0.0.0.0'.
const _hostname = 'localhost';

FutureOr<shelf.Response> Function(shelf.Request) router() {
  final me = Example('gary', 36, DateTime(2020));
  final app = Router();
  app.get('/favicon.ico', (shelf.Request r) async => shelf.Response(303));
  app.get('/example', (shelf.Request r) async {
    return shelf.Response.ok(me.toJson(),
        headers: {'Content-Type': 'application/json'});
  });
  return app.handler;
}

void main(List<String> args) async {
  var parser = ArgParser()..addOption('port', abbr: 'p');
  var result = parser.parse(args);

  // For Google Cloud Run, we respect the PORT environment variable
  var portStr = result['port'] ?? Platform.environment['PORT'] ?? '8080';
  var port = int.tryParse(portStr);

  if (port == null) {
    stdout.writeln('Could not parse port value "$portStr" into a number.');
    // 64: command line usage error
    exitCode = 64;
    return;
  }

  var handler = const shelf.Pipeline()
      .addMiddleware(shelf.logRequests())
      .addHandler(_echoRequest);

  var server = await io.serve(handler, _hostname, port);
  print('Serving at http://${server.address.host}:${server.port}');
}

final app = Router();

Future<shelf.Response> _echoRequest(shelf.Request request) async =>
    shelf.Response.ok('Request for "${request.url}"');


 







//
// Helpers
//


