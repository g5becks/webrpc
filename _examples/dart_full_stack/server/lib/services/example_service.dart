import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:args/args.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:meta/meta.dart';
import 'package:shelf/shelf.dart' as shelf;
import 'package:shelf/shelf_io.dart' as io;

part 'example_service.freezed.dart';
part 'example_service.g.dart';

// example v0.0.1 77d12155b7e5f3476b17b7098ab01499625d632a
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/dart
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
String webRPCVersion() {
  return "v1";
}

// Schema version of your RIDL schema
String WebRPCSchemaVersion() {
  return "v0.0.1";
}

// Schema hash generated from your RIDL schema
String WebRPCSchemaHash() {
  return "77d12155b7e5f3476b17b7098ab01499625d632a";
}

// **********************************************************************
// MESSAGE TYPES.
// **********************************************************************
@freezed
abstract class Kind with _$Kind {
  const factory Kind.user() = USER;
  const factory Kind.admin() = ADMIN;
  factory Kind.fromJson(Map<String, dynamic> json) => _$KindFromJson(json);
}

@freezed
abstract class Empty with _$Empty {
  @JsonSerializable(explicitToJson: true)
  factory Empty() = _Empty;
  factory Empty.fromJson(Map<String, dynamic> json) => _$EmptyFromJson(json);
}

@freezed
abstract class User with _$User {
  @JsonSerializable(explicitToJson: true)
  factory User({
    @required int id,
    @JsonKey(name: 'USERNAME') @required String username,
    @required String role,
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

@freezed
abstract class SearchFilter with _$SearchFilter {
  @JsonSerializable(explicitToJson: true)
  factory SearchFilter({
    @required String q,
  }) = _SearchFilter;
  factory SearchFilter.fromJson(Map<String, dynamic> json) =>
      _$SearchFilterFromJson(json);
}

@freezed
abstract class Version with _$Version {
  @JsonSerializable(explicitToJson: true)
  factory Version({
    @required String webrpcVersion,
    @required String schemaVersion,
    @required String schemaHash,
  }) = _Version;
  factory Version.fromJson(Map<String, dynamic> json) =>
      _$VersionFromJson(json);
}

@freezed
abstract class ComplexType with _$ComplexType {
  @JsonSerializable(explicitToJson: true)
  factory ComplexType({
    @required Map<String, dynamic> meta,
    @required Map<String, Map<String, int>> metaNestedExample,
    @required List<String> namesList,
    @required List<int> numsList,
    @required List<List<String>> doubleArray,
    @required List<User> listOfUsers,
    @required Map<String, User> mapOfUsers,
    @required User user,
    List<Map<String, int>> listOfMaps,
  }) = _ComplexType;
  factory ComplexType.fromJson(Map<String, dynamic> json) =>
      _$ComplexTypeFromJson(json);
}

// *********************************************************************
// ExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class _ExampleServiceUpdateNameArgs
    with _$_ExampleServiceUpdateNameArgs {
  @JsonSerializable(explicitToJson: true)
  factory _ExampleServiceUpdateNameArgs({
    @required String username,
  }) = _ExampleServiceUpdateNameArgs_Freezed;
  factory _ExampleServiceUpdateNameArgs.fromJson(Map<String, dynamic> json) =>
      _$_ExampleServiceUpdateNameArgsFromJson(json);
}

@freezed
abstract class _ExampleServiceGetUserArgs with _$_ExampleServiceGetUserArgs {
  @JsonSerializable(explicitToJson: true)
  factory _ExampleServiceGetUserArgs({
    @required Map<String, String> header,
    @required int userID,
  }) = _ExampleServiceGetUserArgs_Freezed;
  factory _ExampleServiceGetUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_ExampleServiceGetUserArgsFromJson(json);
}

@freezed
abstract class _ExampleServiceFindUserArgs with _$_ExampleServiceFindUserArgs {
  @JsonSerializable(explicitToJson: true)
  factory _ExampleServiceFindUserArgs({
    @required SearchFilter s,
  }) = _ExampleServiceFindUserArgs_Freezed;
  factory _ExampleServiceFindUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_ExampleServiceFindUserArgsFromJson(json);
}

// *********************************************************************
// ExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class StatusResult with _$StatusResult {
  @JsonSerializable(explicitToJson: true)
  factory StatusResult({
    @required bool status,
  }) = _StatusResult;
  factory StatusResult.fromJson(Map<String, dynamic> json) =>
      _$StatusResultFromJson(json);
}

@freezed
abstract class VersionResult with _$VersionResult {
  @JsonSerializable(explicitToJson: true)
  factory VersionResult({
    @required Version version,
  }) = _VersionResult;
  factory VersionResult.fromJson(Map<String, dynamic> json) =>
      _$VersionResultFromJson(json);
}

@freezed
abstract class GetUserResult with _$GetUserResult {
  @JsonSerializable(explicitToJson: true)
  factory GetUserResult({
    @required int code,
    @required User user,
  }) = _GetUserResult;
  factory GetUserResult.fromJson(Map<String, dynamic> json) =>
      _$GetUserResultFromJson(json);
}

@freezed
abstract class FindUserResult with _$FindUserResult {
  @JsonSerializable(explicitToJson: true)
  factory FindUserResult({
    @required String name,
    @required User user,
  }) = _FindUserResult;
  factory FindUserResult.fromJson(Map<String, dynamic> json) =>
      _$FindUserResultFromJson(json);
}

// *********************************************************************
// AnotherExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class _AnotherExampleServiceGetAccountArgs
    with _$_AnotherExampleServiceGetAccountArgs {
  @JsonSerializable(explicitToJson: true)
  factory _AnotherExampleServiceGetAccountArgs({
    @required Map<String, String> header,
    @required int userID,
  }) = _AnotherExampleServiceGetAccountArgs_Freezed;
  factory _AnotherExampleServiceGetAccountArgs.fromJson(
          Map<String, dynamic> json) =>
      _$_AnotherExampleServiceGetAccountArgsFromJson(json);
}

@freezed
abstract class _AnotherExampleServiceGetUsersArgs
    with _$_AnotherExampleServiceGetUsersArgs {
  @JsonSerializable(explicitToJson: true)
  factory _AnotherExampleServiceGetUsersArgs({
    @required SearchFilter s,
  }) = _AnotherExampleServiceGetUsersArgs_Freezed;
  factory _AnotherExampleServiceGetUsersArgs.fromJson(
          Map<String, dynamic> json) =>
      _$_AnotherExampleServiceGetUsersArgsFromJson(json);
}

// *********************************************************************
// AnotherExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class AnotherExampleServiceStatusResult
    with _$AnotherExampleServiceStatusResult {
  @JsonSerializable(explicitToJson: true)
  factory AnotherExampleServiceStatusResult({
    @required bool status,
  }) = _AnotherExampleServiceStatusResult;
  factory AnotherExampleServiceStatusResult.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceStatusResultFromJson(json);
}

@freezed
abstract class GetVersionResult with _$GetVersionResult {
  @JsonSerializable(explicitToJson: true)
  factory GetVersionResult({
    @required Version version,
  }) = _GetVersionResult;
  factory GetVersionResult.fromJson(Map<String, dynamic> json) =>
      _$GetVersionResultFromJson(json);
}

@freezed
abstract class GetAccountResult with _$GetAccountResult {
  @JsonSerializable(explicitToJson: true)
  factory GetAccountResult({
    @required int code,
    @required User user,
  }) = _GetAccountResult;
  factory GetAccountResult.fromJson(Map<String, dynamic> json) =>
      _$GetAccountResultFromJson(json);
}

@freezed
abstract class GetUsersResult with _$GetUsersResult {
  @JsonSerializable(explicitToJson: true)
  factory GetUsersResult({
    @required String name,
    @required User user,
  }) = _GetUsersResult;
  factory GetUsersResult.fromJson(Map<String, dynamic> json) =>
      _$GetUsersResultFromJson(json);
}

// *********************************************************************
// SERVICE INTERFACES.
// *********************************************************************
// TODO implement ExampleService.
abstract class ExampleService {
  FutureOr<void> ping();
  FutureOr<StatusResult> status();
  FutureOr<void> updateName({
    @required String username,
  });
  FutureOr<VersionResult> version();
  FutureOr<GetUserResult> getUser({
    @required Map<String, String> header,
    @required int userID,
  });
  FutureOr<FindUserResult> findUser({
    @required SearchFilter s,
  });
}

// TODO implement AnotherExampleService.
abstract class AnotherExampleService {
  FutureOr<void> pingServer();
  FutureOr<AnotherExampleServiceStatusResult> status();
  FutureOr<GetVersionResult> getVersion();
  FutureOr<GetAccountResult> getAccount({
    @required Map<String, String> header,
    @required int userID,
  });
  FutureOr<GetUsersResult> getUsers({
    @required SearchFilter s,
  });
}

// *********************************************************************
// SERVER IMPLEMENTATION.
// *********************************************************************
class WebRpcServer {
  // For Google Cloud Run, set _hostname to '0.0.0.0'.
  String _hostname;
  // Provide a {Logger} implementation to log exceptions.
  RpcLogger _log;
  // Provide a preconfigured shelf.Pipeline with desired middleware.
  Set<shelf.Middleware> _middleware;
  // Shelf Pipeline.
  final shelf.Pipeline _pipeline = const shelf.Pipeline();
  // A reference to the http server.
  HttpServer _server;
  // Expose internal server for user customization.
  HttpServer get server => _server;
  final ExampleService exampleService;
  final AnotherExampleService anotherExampleService;
  WebRpcServer({
    @required this.exampleService,
    @required this.anotherExampleService,
    RpcLogger logger,
    String hostName = 'localhost',
    List<shelf.Middleware> middleware,
  }) {
    _hostname = hostName;
    _log = logger ?? _rpcLogger;
    _middleware = middleware?.toSet() ?? [shelf.logRequests()];
  }

  bool _jsonFriendly(shelf.Request r) =>
      r.headers['Content-Type'].contains('application/json') &&
      r.headers['Accept'].contains('application/json');

  FutureOr<shelf.Response> _requestHandler(shelf.Request r) async {
    final route = r.url.path;
    if (r.method != 'POST') {
      final info =
          'unsupported method: ${r.method}, (only POST is allowed. path: $route';
      _log.info(info);
      return _rpcResp.BadRoute(
        route,
        msg: info,
      );
    }

    if (!_jsonFriendly(r)) {
      final info =
          'unexpected Content-Type: ${r.headers['Content-Type']} or Accept: ${r.headers['Accept']}. path: $route';
      _log.info(info);
      return _rpcResp.BadRoute(
        route,
        msg: info,
      );
    }

    switch (r.url.path) {
      case '/rpc/ExampleService/Ping':
        {
          return _handleExampleServicePing(r);
        }
        break;

      case '/rpc/ExampleService/Status':
        {
          return _handleExampleServiceStatus(r);
        }
        break;

      case '/rpc/ExampleService/UpdateName':
        {
          return _handleExampleServiceUpdateName(r);
        }
        break;

      case '/rpc/ExampleService/Version':
        {
          return _handleExampleServiceVersion(r);
        }
        break;

      case '/rpc/ExampleService/GetUser':
        {
          return _handleExampleServiceGetUser(r);
        }
        break;

      case '/rpc/ExampleService/FindUser':
        {
          return _handleExampleServiceFindUser(r);
        }
        break;

      case '/rpc/AnotherExampleService/PingServer':
        {
          return _handleAnotherExampleServicePingServer(r);
        }
        break;

      case '/rpc/AnotherExampleService/Status':
        {
          return _handleAnotherExampleServiceStatus(r);
        }
        break;

      case '/rpc/AnotherExampleService/GetVersion':
        {
          return _handleAnotherExampleServiceGetVersion(r);
        }
        break;

      case '/rpc/AnotherExampleService/GetAccount':
        {
          return _handleAnotherExampleServiceGetAccount(r);
        }
        break;

      case '/rpc/AnotherExampleService/GetUsers':
        {
          return _handleAnotherExampleServiceGetUsers(r);
        }
        break;

      default:
        {
          final info = 'no handler for path: $route';
          _log.info(info);
          return _rpcResp.BadRoute(
            route,
            msg: info,
          );
        }
        break;
    }
  }

  FutureOr<shelf.Response> _handleExampleServicePing(shelf.Request r) async {
    try {
      // Attempt to call service method.

      await exampleService.ping();
      return _rpcResp.Ok();
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/Ping');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/Ping');
    }
  }

  FutureOr<shelf.Response> _handleExampleServiceStatus(shelf.Request r) async {
    try {
      // Attempt to call service method.
      final StatusResult result = await exampleService.status();
      return _rpcResp.Ok(
        json: jsonEncode(
          result.toJson(),
        ),
      );
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/Status');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/Status');
    }
  }

  FutureOr<shelf.Response> _handleExampleServiceUpdateName(
      shelf.Request r) async {
    try {
      // Attempt to call service method.
      final json = await r.readAsString();
      final _ExampleServiceUpdateNameArgs args =
          _ExampleServiceUpdateNameArgs.fromJson(
        jsonDecode(json),
      );

      await exampleService.updateName(
        username: args.username,
      );
      return _rpcResp.Ok();
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/UpdateName');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/UpdateName');
    }
  }

  FutureOr<shelf.Response> _handleExampleServiceVersion(shelf.Request r) async {
    try {
      // Attempt to call service method.
      final VersionResult result = await exampleService.version();
      return _rpcResp.Ok(
        json: jsonEncode(
          result.toJson(),
        ),
      );
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/Version');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/Version');
    }
  }

  FutureOr<shelf.Response> _handleExampleServiceGetUser(shelf.Request r) async {
    try {
      // Attempt to call service method.
      final json = await r.readAsString();
      final _ExampleServiceGetUserArgs args =
          _ExampleServiceGetUserArgs.fromJson(
        jsonDecode(json),
      );
      final GetUserResult result = await exampleService.getUser(
        header: args.header,
        userID: args.userID,
      );
      return _rpcResp.Ok(
        json: jsonEncode(
          result.toJson(),
        ),
      );
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/GetUser');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/GetUser');
    }
  }

  FutureOr<shelf.Response> _handleExampleServiceFindUser(
      shelf.Request r) async {
    try {
      // Attempt to call service method.
      final json = await r.readAsString();
      final _ExampleServiceFindUserArgs args =
          _ExampleServiceFindUserArgs.fromJson(
        jsonDecode(json),
      );
      final FindUserResult result = await exampleService.findUser(
        s: args.s,
      );
      return _rpcResp.Ok(
        json: jsonEncode(
          result.toJson(),
        ),
      );
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/FindUser');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/ExampleService/FindUser');
    }
  }

  FutureOr<shelf.Response> _handleAnotherExampleServicePingServer(
      shelf.Request r) async {
    try {
      // Attempt to call service method.

      await anotherExampleService.pingServer();
      return _rpcResp.Ok();
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/PingServer');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/PingServer');
    }
  }

  FutureOr<shelf.Response> _handleAnotherExampleServiceStatus(
      shelf.Request r) async {
    try {
      // Attempt to call service method.
      final AnotherExampleServiceStatusResult result =
          await anotherExampleService.status();
      return _rpcResp.Ok(
        json: jsonEncode(
          result.toJson(),
        ),
      );
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/Status');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/Status');
    }
  }

  FutureOr<shelf.Response> _handleAnotherExampleServiceGetVersion(
      shelf.Request r) async {
    try {
      // Attempt to call service method.
      final GetVersionResult result = await anotherExampleService.getVersion();
      return _rpcResp.Ok(
        json: jsonEncode(
          result.toJson(),
        ),
      );
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/GetVersion');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/GetVersion');
    }
  }

  FutureOr<shelf.Response> _handleAnotherExampleServiceGetAccount(
      shelf.Request r) async {
    try {
      // Attempt to call service method.
      final json = await r.readAsString();
      final _AnotherExampleServiceGetAccountArgs args =
          _AnotherExampleServiceGetAccountArgs.fromJson(
        jsonDecode(json),
      );
      final GetAccountResult result = await anotherExampleService.getAccount(
        header: args.header,
        userID: args.userID,
      );
      return _rpcResp.Ok(
        json: jsonEncode(
          result.toJson(),
        ),
      );
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/GetAccount');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/GetAccount');
    }
  }

  FutureOr<shelf.Response> _handleAnotherExampleServiceGetUsers(
      shelf.Request r) async {
    try {
      // Attempt to call service method.
      final json = await r.readAsString();
      final _AnotherExampleServiceGetUsersArgs args =
          _AnotherExampleServiceGetUsersArgs.fromJson(
        jsonDecode(json),
      );
      final GetUsersResult result = await anotherExampleService.getUsers(
        s: args.s,
      );
      return _rpcResp.Ok(
        json: jsonEncode(
          result.toJson(),
        ),
      );
    }
    // Catch WebRPCExceptions.
    on WebRPCException catch (e, stackTrace) {
      _logWebRpcExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/GetUsers');
    }
    // Catch all other exceptions.
    on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      return _rpcResp.Fail('/rpc/AnotherExampleService/GetUsers');
    }
  }

  ArgResults _parseArgs(List<String> args) {
    final parser = ArgParser()..addOption('port', abbr: 'p');
    try {
      return parser.parse(args);
    } on ArgParserException catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
      print('arg parsing error occured: $e');
      rethrow;
    }
  }

  // For Google Cloud Run, we respect the PORT environment variable
  int _getPort(ArgResults args) =>
      int.tryParse(args['port'] ?? Platform.environment['PORT'] ?? '8080');

  void _configurePipeline() => _middleware.forEach(
        (mddlwr) => _pipeline.addMiddleware(mddlwr),
      );

  Future<void> serve(List<String> args,
      {SecurityContext securityContext,
      int backlog,
      bool shared = false}) async {
    final result = _parseArgs(args);
    final port = _getPort(result);

    if (port == null) {
      stdout.writeln(
          'Could not parse port value "${port.toString()}" into a number.');
      // 64: command line usage error
      exitCode = 64;
      return;
    }

    _configurePipeline();
    final handler = _pipeline.addHandler(_requestHandler);
    _server = await io.serve(handler, _hostname, port,
        securityContext: securityContext, backlog: backlog, shared: shared);
    print('Serving at http://${_server.address.host}:${_server.port}');
  }
}

// *********************************************************************
// SERVER-SIDE HELPER CODE.
// *********************************************************************

// The log level for [RpcLogger] and [WebRPCException]s.
enum RpcLogLevel {
  Info,
  Fine,
  Finer,
  Finest,
  Config,
  Warning,
  Severe,
  Shout,
}

// This exception should be thrown from all WEBRPC-DART service method implementations.
// Throwing this exception and providing an [RpcLogLevel] allows the rpc logging mechanism to log all caught excetpions at the correct level.
class WebRPCException extends HttpException {
  @override
  final String message;
  final RpcLogLevel level;
  WebRPCException(
      {this.message = 'webrpc error', this.level = RpcLogLevel.Info})
      : super('$message');
}

String _rpcLogMsg(
  WebRPCException exc, [
  Object error,
  stackTrace,
]) =>
    '{message: ${exc.message}, level: ${exc.level}, timeStamp: ${DateTime.now().toString()}, error: $error, stackTrace,: $stackTrace}';

// Helper Method for logging WebRPCExceptions.
void _logWebRpcExc(
  RpcLogger log,
  WebRPCException exc, [
  Object error,
  stackTrace,
]) {
  switch (exc.level) {
    case RpcLogLevel.Config:
      {
        log.config(
          _rpcLogMsg(
            exc,
            error,
            stackTrace,
          ),
          error,
          stackTrace,
        );
      }
      break;
    case RpcLogLevel.Fine:
      {
        log.fine(
          _rpcLogMsg(
            exc,
            error,
            stackTrace,
          ),
          error,
          stackTrace,
        );
      }
      break;
    case RpcLogLevel.Finer:
      {
        log.finer(
          _rpcLogMsg(
            exc,
            error,
            stackTrace,
          ),
          error,
          stackTrace,
        );
      }
      break;
    case RpcLogLevel.Finest:
      {
        log.finest(
          _rpcLogMsg(
            exc,
            error,
            stackTrace,
          ),
          error,
          stackTrace,
        );
      }
      break;
    case RpcLogLevel.Info:
      {
        log.info(
          _rpcLogMsg(
            exc,
            error,
            stackTrace,
          ),
          error,
          stackTrace,
        );
      }
      break;
    case RpcLogLevel.Warning:
      {
        log.warning(
          _rpcLogMsg(
            exc,
            error,
            stackTrace,
          ),
          error,
          stackTrace,
        );
      }
      break;
    case RpcLogLevel.Severe:
      {
        log.severe(
          _rpcLogMsg(
            exc,
            error,
            stackTrace,
          ),
          error,
          stackTrace,
        );
      }
      break;
    case RpcLogLevel.Shout:
      {
        log.shout(
          _rpcLogMsg(
            exc,
            error,
            stackTrace,
          ),
          error,
          stackTrace,
        );
      }
  }
}

// Contains static method helpers for handling requests.
class _rpcResp {
  static String _message(String status, {String info}) =>
      'webrpc error: $status, details: $info';

  static const _jsonHeader = {
    'Content-Type': 'application/json',
    'X-Content-Type-Options': 'nosniff'
  };

  static shelf.Response _jsonResp(int code, {dynamic json}) => shelf.Response(
        code,
        headers: _jsonHeader,
        body: json,
      );

  static shelf.Response Ok({String json}) => shelf.Response.ok(
        json,
        headers: _jsonHeader,
      );

  static shelf.Response Found(String route, {String msg = ''}) =>
      shelf.Response.found(route, headers: _jsonHeader, body: msg);

  static shelf.Response MovedPerm(String route, {String msg = ''}) =>
      shelf.Response.movedPermanently(
        route,
        headers: _jsonHeader,
      );

  static shelf.Response NotModified() =>
      shelf.Response.notModified(headers: _jsonHeader);

  static shelf.Response SeeOther(String route, {String msg = ''}) =>
      shelf.Response.seeOther(
        route,
        headers: _jsonHeader,
        body: msg,
      );

  static shelf.Response Unknown(String route, {String msg = ''}) => _jsonResp(
        _err.Unknown.code,
        json: _RpcErr(
                message: _message(_err.Unknown.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.Unknown)
            .toJson(),
      );

  static shelf.Response Fail(String route, {String msg = ''}) => _jsonResp(
        _err.Fail.code,
        json: _RpcErr(
                message: _message(_err.Fail.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.Fail)
            .toJson(),
      );

  static shelf.Response Canceled(String route, {String msg = ''}) => _jsonResp(
        _err.Canceled.code,
        json: _RpcErr(
                message: _message(_err.Canceled.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.Canceled)
            .toJson(),
      );

  static shelf.Response InvalidArgument(String route, {String msg = ''}) =>
      _jsonResp(
        _err.InvalidArgument.code,
        json: _RpcErr(
                message: _message(_err.InvalidArgument.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.InvalidArgument)
            .toJson(),
      );

  static shelf.Response DeadlineExceeded(String route, {String msg = ''}) =>
      _jsonResp(
        _err.DeadlineExceeded.code,
        json: _RpcErr(
                message: _message(_err.DeadlineExceeded.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.DeadlineExceeded)
            .toJson(),
      );

  static shelf.Response NotFound(String route, {String msg = ''}) => _jsonResp(
        _err.NotFound.code,
        json: _RpcErr(
                message: _message(_err.NotFound.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.NotFound)
            .toJson(),
      );

  static shelf.Response BadRoute(String route, {String msg = ''}) => _jsonResp(
        _err.BadRoute.code,
        json: _RpcErr(
                message: _message(_err.BadRoute.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.BadRoute)
            .toJson(),
      );

  static shelf.Response AlreadyExists(String route, {String msg = ''}) =>
      _jsonResp(
        _err.AlreadyExists.code,
        json: _RpcErr(
                message: _message(_err.AlreadyExists.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.AlreadyExists)
            .toJson(),
      );

  static shelf.Response PermissionDenied(String route, {String msg = ''}) =>
      _jsonResp(
        _err.PermissionDenied.code,
        json: _RpcErr(
                message: _message(_err.PermissionDenied.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.PermissionDenied)
            .toJson(),
      );

  static shelf.Response Unauthenticated(String route, {String msg = ''}) =>
      _jsonResp(
        _err.Unauthenticated.code,
        json: _RpcErr(
                message: _message(_err.Unauthenticated.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.Unauthenticated)
            .toJson(),
      );

  static shelf.Response ResourceExhausted(String route, {String msg = ''}) =>
      _jsonResp(
        _err.ResourceExhausted.code,
        json: _RpcErr(
                message: _message(_err.ResourceExhausted.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.ResourceExhausted)
            .toJson(),
      );

  static shelf.Response FailedPrecondition(String route, {String msg = ''}) =>
      _jsonResp(
        _err.FailedPrecondition.code,
        json: _RpcErr(
                message: _message(_err.FailedPrecondition.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.FailedPrecondition)
            .toJson(),
      );

  static shelf.Response Aborted(String route, {String msg = ''}) => _jsonResp(
        _err.Aborted.code,
        json: _RpcErr(
                message: _message(_err.Aborted.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.Aborted)
            .toJson(),
      );

  static shelf.Response OutOfRange(String route, {String msg = ''}) =>
      _jsonResp(
        _err.OutOfRange.code,
        json: _RpcErr(
                message: _message(_err.OutOfRange.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.OutOfRange)
            .toJson(),
      );

  static shelf.Response Unimplemented(String route, {String msg = ''}) =>
      _jsonResp(
        _err.Unimplemented.code,
        json: _RpcErr(
                message: _message(_err.Unimplemented.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.Unimplemented)
            .toJson(),
      );

  static shelf.Response Internal(String route, {String msg = ''}) => _jsonResp(
        _err.Internal.code,
        json: _RpcErr(
                message: _message(_err.Internal.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.Internal)
            .toJson(),
      );

  static shelf.Response Unavailable(String route, {String msg = ''}) =>
      _jsonResp(
        _err.Unavailable.code,
        json: _RpcErr(
                message: _message(_err.Unavailable.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.Unavailable)
            .toJson(),
      );

  static shelf.Response DataLoss(String route, {String msg = ''}) => _jsonResp(
        _err.DataLoss.code,
        json: _RpcErr(
                message: _message(_err.DataLoss.status, info: msg),
                path: route,
                time: DateTime.now(),
                httpErr: _err.DataLoss)
            .toJson(),
      );
}

String _logMsg(
  Exception exc, [
  Object error,
  StackTrace stackTrace,
]) =>
    '{message: ${exc.toString()}, timeStamp: ${DateTime.now().toString()}, error: $error, stackTrace: $stackTrace}';

void _logExc(
  RpcLogger log,
  Exception exc, [
  Object error,
  StackTrace stackTrace,
]) =>
    log.warning(_logMsg(exc, error, stackTrace));

abstract class RpcLogger {
  void _log(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      print(
          '{message: $message}, error: $error, stackTrace: $stackTrace, time: ${DateTime.now()}');
  void finest(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void finer(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void fine(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void config(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void info(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void warning(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void severe(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void shout(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
}

class _Logger extends RpcLogger {
  _Logger();
}

final _rpcLogger = _Logger();

// Contains static fields for creating and identifying http errors.
class _err {
  // Unknown error. For example when handling errors raised by APIs that do not
  // return enough error information.
  static const _HttpErr Unknown = _HttpErr('unknown', 400);
  // 422 (Unprocessable Entity) Fail error. General failure error type.
  static const _HttpErr Fail = _HttpErr('fail', 422);
  // RequestTimeout Canceled indicates the operation was cancelled (typically by the caller).
  static const _HttpErr Canceled = _HttpErr('canceled', 408);
  // InvalidArgument indicates client specified an invalid argument. It
  // indicates arguments that are problematic regardless of the state of the
  // system (i.e. a malformed file name, required argument, number out of range,
  // etc.).
  static const _HttpErr InvalidArgument = _HttpErr('invalid argument', 422);
  // RequestTimeOut. DeadlineExceeded means operation expired before completion. For operations
  // that change the state of the system, this error may be returned even if the
  // operation has completed successfully (timeout).
  static const _HttpErr DeadlineExceeded = _HttpErr('deadline exceeded', 408);
  // NotFound means some requested entity was not found.
  static const _HttpErr NotFound = _HttpErr('not found', 404);
  // BadRoute means that the requested URL path wasn't routable to a webrpc
  // service and method. This is returned by the generated server, and usually
  // shouldn't be returned by applications. Instead, applications should use
  // NotFound or Unimplemented.
  static const _HttpErr BadRoute = _HttpErr('bad route', 404);
  // AlreadyExists means an attempt to create an entity failed because one
  // already exists. Conflict.
  static const _HttpErr AlreadyExists = _HttpErr('already exists', 409);
  // PermissionDenied indicates the caller does not have permission to execute
  // the specified operation. It must not be used if the caller cannot be
  // identified (Unauthenticated).
  static const _HttpErr PermissionDenied = _HttpErr('permission denied', 403);
  // Unauthenticated indicates the request does not have valid authentication
  // credentials for the operation. Unauthorized.
  static const _HttpErr Unauthenticated = _HttpErr('unauthenticated', 401);
  // ResourceExhausted indicates some resource has been exhausted, perhaps a
  // per-user quota, or perhaps the entire file system is out of space. Forbidden.
  static const _HttpErr ResourceExhausted = _HttpErr('resource exhausted', 403);
  // FailedPrecondition indicates operation was rejected because the system is
  // not in a state required for the operation's execution. For example, doing
  // an rmdir operation on a directory that is non-empty, or on a non-directory
  // object, or when having conflicting read-modify-write on the same resource. Precondition failed.
  static const _HttpErr FailedPrecondition =
      _HttpErr('failed precondition', 412);
  // Aborted indicates the operation was aborted, typically due to a concurrency
  // issue like sequencer check failures, transaction aborts, etc.
  static const _HttpErr Aborted = _HttpErr('aborted', 409);
  // OutOfRange means operation was attempted past the valid range. For example,
  // seeking or reading past end of a paginated collection.
  //
  // Unlike InvalidArgument, this error indicates a problem that may be fixed if
  // the system state changes (i.e. adding more items to the collection).
  //
  // There is a fair bit of overlap between FailedPrecondition and OutOfRange.
  // We recommend using OutOfRange (the more specific error) when it applies so
  // that callers who are iterating through a space can easily look for an
  // OutOfRange error to detect when they are done.
  static const _HttpErr OutOfRange = _HttpErr('out of range', 400);
  // Unimplemented indicates operation is not implemented or not
  // supported/enabled in this service.
  static const _HttpErr Unimplemented = _HttpErr('unimplemented', 501);
  // Internal errors. When some invariants expected by the underlying system
  // have been broken. In other words, something bad happened in the library or
  // backend service. Do not confuse with HTTP Internal Server Error; an
  // Internal error could also happen on the client code, i.e. when parsing a
  // server response.
  static const _HttpErr Internal = _HttpErr('internal', 500);
  // Unavailable indicates the service is currently unavailable. This is a most
  // likely a transient condition and may be corrected by retrying with a
  // backoff. Service Unavailable.
  static const _HttpErr Unavailable = _HttpErr('unavailable', 503);
  // DataLoss indicates unrecoverable data loss or corruption.
  static const _HttpErr DataLoss = _HttpErr('data loss', 500);
}

// *********************************************************************
// WEBRPC-DART HELPER CODE.
// *********************************************************************

// An http error.
class _HttpErr {
  final String status;
  final int code;
  const _HttpErr(this.status, this.code);

  Map<String, dynamic> toMap() => {'status': status, 'code': code};
  String toJson() => jsonEncode(toMap());
  static _HttpErr fromMap(Map<String, dynamic> map) =>
      _HttpErr(map['status'] as String, map['code'] as int);

  static _HttpErr fromJson(dynamic json) => fromMap(
        jsonDecode(json),
      );
}

// An error created by the rpc server.
class _RpcErr {
  final String message;
  final String path;
  final DateTime time;
  final _HttpErr httpErr;
  const _RpcErr({this.message, this.path, this.httpErr, this.time});
  static const _RpcErr unknown = _RpcErr(
      message: 'an unknown error has occured',
      path: 'unknown',
      httpErr: _HttpErr('unknown', 400),
      time: null);
  Map<String, dynamic> toMap() => {
        'message': message,
        'path': path,
        'httpErr': httpErr.toMap(),
        'time-stamp': time.toString()
      };
  String toJson() => jsonEncode(toMap());
  static _RpcErr fromMap(Map<String, dynamic> map) => _RpcErr(
        message: map['message'] as String,
        path: map['path'] as String,
        time: DateTime.parse(
          map['time-stamp'],
        ),
        httpErr: _HttpErr.fromMap(
          map['httpErr'],
        ),
      );
  static _RpcErr fromJson(dynamic json) => fromMap(
        jsonDecode(json),
      );
}
