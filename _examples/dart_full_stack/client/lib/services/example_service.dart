import 'dart:async';
import 'dart:convert';

import 'package:meta/meta.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import 'package:http/http.dart' as http;

import 'package:flutter/foundation.dart';

part 'example_service.freezed.dart';
part 'example_service.g.dart';

// example v0.0.1 8020254366f497d3c08759ae5f5c68f270d8ff1a
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/dart
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
String webRPCVersion() {
  return "v1";
}

// Schema version of your RIDL schema
String WebRPCSchemaVersion() {
  return "v0.0.1";
}

// Schema hash generated from your RIDL schema
String WebRPCSchemaHash() {
  return "8020254366f497d3c08759ae5f5c68f270d8ff1a";
}

// **********************************************************************
// MESSAGE TYPES.
// **********************************************************************
@freezed
abstract class Kind with _$Kind {
  const factory Kind.user() = USER;
  const factory Kind.admin() = ADMIN;
  factory Kind.fromJson(Map<String, dynamic> json) => _$KindFromJson(json);
}

@freezed
abstract class Empty with _$Empty {
  @JsonSerializable(explicitToJson: true)
  factory Empty() = _Empty;
  factory Empty.fromJson(Map<String, dynamic> json) => _$EmptyFromJson(json);
}

@freezed
abstract class User with _$User {
  @JsonSerializable(explicitToJson: true)
  factory User({
    @required int id,
    @JsonKey(name: 'USERNAME') @required String username,
    @required String role,
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

@freezed
abstract class SearchFilter with _$SearchFilter {
  @JsonSerializable(explicitToJson: true)
  factory SearchFilter({
    @required int id,
  }) = _SearchFilter;
  factory SearchFilter.fromJson(Map<String, dynamic> json) =>
      _$SearchFilterFromJson(json);
}

@freezed
abstract class Version with _$Version {
  @JsonSerializable(explicitToJson: true)
  factory Version({
    @required String webrpcVersion,
    @required String schemaVersion,
    @required String schemaHash,
  }) = _Version;
  factory Version.fromJson(Map<String, dynamic> json) =>
      _$VersionFromJson(json);
}

@freezed
abstract class ComplexType with _$ComplexType {
  @JsonSerializable(explicitToJson: true)
  factory ComplexType({
    @required Map<String, dynamic> meta,
    @required Map<String, Map<String, int>> metaNestedExample,
    @required List<String> namesList,
    @required List<int> numsList,
    @required List<List<String>> doubleArray,
    @required List<User> listOfUsers,
    @required Map<String, User> mapOfUsers,
    @required User user,
    List<Map<String, int>> listOfMaps,
  }) = _ComplexType;
  factory ComplexType.fromJson(Map<String, dynamic> json) =>
      _$ComplexTypeFromJson(json);
}

// *********************************************************************
// ExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class _GetUserArgs with _$_GetUserArgs {
  @JsonSerializable(explicitToJson: true)
  factory _GetUserArgs({
    @required int userID,
  }) = _GetUserArgs_Freezed;
  factory _GetUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_GetUserArgsFromJson(json);
}

@freezed
abstract class _UpdateNameArgs with _$_UpdateNameArgs {
  @JsonSerializable(explicitToJson: true)
  factory _UpdateNameArgs({
    @required int id,
    @required String username,
  }) = _UpdateNameArgs_Freezed;
  factory _UpdateNameArgs.fromJson(Map<String, dynamic> json) =>
      _$_UpdateNameArgsFromJson(json);
}

@freezed
abstract class _FindUserByIdArgs with _$_FindUserByIdArgs {
  @JsonSerializable(explicitToJson: true)
  factory _FindUserByIdArgs({
    @required SearchFilter s,
  }) = _FindUserByIdArgs_Freezed;
  factory _FindUserByIdArgs.fromJson(Map<String, dynamic> json) =>
      _$_FindUserByIdArgsFromJson(json);
}

@freezed
abstract class _AddUserArgs with _$_AddUserArgs {
  @JsonSerializable(explicitToJson: true)
  factory _AddUserArgs({
    @required User user,
  }) = _AddUserArgs_Freezed;
  factory _AddUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_AddUserArgsFromJson(json);
}

@freezed
abstract class _DeleteUserArgs with _$_DeleteUserArgs {
  @JsonSerializable(explicitToJson: true)
  factory _DeleteUserArgs({
    @required int id,
  }) = _DeleteUserArgs_Freezed;
  factory _DeleteUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_DeleteUserArgsFromJson(json);
}

// *********************************************************************
// ExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class StatusResult with _$StatusResult {
  @JsonSerializable(explicitToJson: true)
  factory StatusResult({
    @required bool status,
  }) = _StatusResult;
  factory StatusResult.fromJson(Map<String, dynamic> json) =>
      _$StatusResultFromJson(json);
}

@freezed
abstract class VersionResult with _$VersionResult {
  @JsonSerializable(explicitToJson: true)
  factory VersionResult({
    @required Version version,
  }) = _VersionResult;
  factory VersionResult.fromJson(Map<String, dynamic> json) =>
      _$VersionResultFromJson(json);
}

@freezed
abstract class GetUserResult with _$GetUserResult {
  @JsonSerializable(explicitToJson: true)
  factory GetUserResult({
    @required User user,
  }) = _GetUserResult;
  factory GetUserResult.fromJson(Map<String, dynamic> json) =>
      _$GetUserResultFromJson(json);
}

@freezed
abstract class UpdateNameResult with _$UpdateNameResult {
  @JsonSerializable(explicitToJson: true)
  factory UpdateNameResult({
    @required bool wasUpdated,
  }) = _UpdateNameResult;
  factory UpdateNameResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateNameResultFromJson(json);
}

@freezed
abstract class FindUserByIdResult with _$FindUserByIdResult {
  @JsonSerializable(explicitToJson: true)
  factory FindUserByIdResult({
    @required String name,
    @required User user,
  }) = _FindUserByIdResult;
  factory FindUserByIdResult.fromJson(Map<String, dynamic> json) =>
      _$FindUserByIdResultFromJson(json);
}

@freezed
abstract class AddUserResult with _$AddUserResult {
  @JsonSerializable(explicitToJson: true)
  factory AddUserResult({
    @required bool wasAdded,
  }) = _AddUserResult;
  factory AddUserResult.fromJson(Map<String, dynamic> json) =>
      _$AddUserResultFromJson(json);
}

@freezed
abstract class ListUsersResult with _$ListUsersResult {
  @JsonSerializable(explicitToJson: true)
  factory ListUsersResult({
    @required List<User> users,
  }) = _ListUsersResult;
  factory ListUsersResult.fromJson(Map<String, dynamic> json) =>
      _$ListUsersResultFromJson(json);
}

@freezed
abstract class DeleteUserResult with _$DeleteUserResult {
  @JsonSerializable(explicitToJson: true)
  factory DeleteUserResult({
    @required bool wasDeleted,
  }) = _DeleteUserResult;
  factory DeleteUserResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteUserResultFromJson(json);
}

// *********************************************************************
// Service Interfaces. Useful for testing purposes.
// *********************************************************************

abstract class ExampleServiceRpc {
  Stream<RpcResponse<int>> ping({
    Map<String, String> headers,
  });

  Stream<RpcResponse<StatusResult>> status({
    Map<String, String> headers,
  });

  Stream<RpcResponse<VersionResult>> version({
    Map<String, String> headers,
  });

  Stream<RpcResponse<GetUserResult>> getUser({
    @required int userID,
    Map<String, String> headers,
  });

  Stream<RpcResponse<UpdateNameResult>> updateName({
    @required int id,
    @required String username,
    Map<String, String> headers,
  });

  Stream<RpcResponse<FindUserByIdResult>> findUserById({
    @required SearchFilter s,
    Map<String, String> headers,
  });

  Stream<RpcResponse<AddUserResult>> addUser({
    @required User user,
    Map<String, String> headers,
  });

  Stream<RpcResponse<ListUsersResult>> listUsers({
    Map<String, String> headers,
  });

  Stream<RpcResponse<DeleteUserResult>> deleteUser({
    @required int id,
    Map<String, String> headers,
  });
}

// *********************************************************************
// RpcResponse TYPE.
// *********************************************************************

// This class provides type safe access to the state of an RpcRequest
// and it's Response data. Can be used easily with Bloc. For more info See https://www.azavea.com/blog/2019/12/12/modeling-state-with-typescript/
// See https://pub.dev/packages/freezed to learn how to use this type.
@freezed
abstract class RpcResponse<T> with _$RpcResponse<T> {
  factory RpcResponse.ok({
    @required T data,
  }) = _RpcResponseOk<T>;
  const factory RpcResponse.err({
    @required String reason,
    @required int statusCode,
    String stackTrace,
  }) = _RpcResonseErr<T>;
  const factory RpcResponse.loading() = _RpcResponseLoading<T>;
}
// ***********************************************************************
// WEBRPC-DART SERVICE CLIENTS.
// ***********************************************************************

class ExampleService implements ExampleServiceRpc {
  final String host;
  String _srvcPath = '/rpc/ExampleService/';
  ExampleService({
    this.host = 'localhost',
  }) {
    _srvcPath = '${_removeSlash(host)}/rpc/ExampleService/';
  }

  Future<http.Response> _makeRequest(
    String route, {
    dynamic json = "{}",
    Map<String, String> headers,
  }) {
    final path = '$_srvcPath/$route';
    return http.post(
      path,
      headers: {
        ...?headers,
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: jsonEncode(json),
    );
  }

  _RpcErr _getErr(http.Response r) {
    try {
      return _RpcErr.fromJson(jsonDecode(r.body));
    } on Exception catch (_) {
      return _RpcErr.unknown;
    }
  }

  @override
  Stream<RpcResponse<int>> ping({
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final http.Response response = await _makeRequest(
        'Ping',
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: response.statusCode,
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcResponse<StatusResult>> status({
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final http.Response response = await _makeRequest(
        'Status',
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: StatusResult.fromJson(
          jsonDecode(
            response.body,
          ),
        ),
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcResponse<VersionResult>> version({
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final http.Response response = await _makeRequest(
        'Version',
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: VersionResult.fromJson(
          jsonDecode(
            response.body,
          ),
        ),
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcResponse<GetUserResult>> getUser({
    @required int userID,
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final _GetUserArgs args = _GetUserArgs(
        userID: userID,
      );

      final http.Response response = await _makeRequest(
        'GetUser',
        json: jsonEncode(
          args.toJson(),
        ),
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: GetUserResult.fromJson(
          jsonDecode(
            response.body,
          ),
        ),
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcResponse<UpdateNameResult>> updateName({
    @required int id,
    @required String username,
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final _UpdateNameArgs args = _UpdateNameArgs(
        id: id,
        username: username,
      );

      final http.Response response = await _makeRequest(
        'UpdateName',
        json: jsonEncode(
          args.toJson(),
        ),
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: UpdateNameResult.fromJson(
          jsonDecode(
            response.body,
          ),
        ),
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcResponse<FindUserByIdResult>> findUserById({
    @required SearchFilter s,
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final _FindUserByIdArgs args = _FindUserByIdArgs(
        s: s,
      );

      final http.Response response = await _makeRequest(
        'FindUserById',
        json: jsonEncode(
          args.toJson(),
        ),
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: FindUserByIdResult.fromJson(
          jsonDecode(
            response.body,
          ),
        ),
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcResponse<AddUserResult>> addUser({
    @required User user,
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final _AddUserArgs args = _AddUserArgs(
        user: user,
      );

      final http.Response response = await _makeRequest(
        'AddUser',
        json: jsonEncode(
          args.toJson(),
        ),
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: AddUserResult.fromJson(
          jsonDecode(
            response.body,
          ),
        ),
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcResponse<ListUsersResult>> listUsers({
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final http.Response response = await _makeRequest(
        'ListUsers',
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: ListUsersResult.fromJson(
          jsonDecode(
            response.body,
          ),
        ),
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcResponse<DeleteUserResult>> deleteUser({
    @required int id,
    Map<String, String> headers,
  }) async* {
    yield const RpcResponse.loading();
    try {
      final _DeleteUserArgs args = _DeleteUserArgs(
        id: id,
      );

      final http.Response response = await _makeRequest(
        'DeleteUser',
        json: jsonEncode(
          args.toJson(),
        ),
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcResponse.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      }
      yield RpcResponse.ok(
        data: DeleteUserResult.fromJson(
          jsonDecode(
            response.body,
          ),
        ),
      );
    } on Exception catch (e, stackTrace) {
      yield RpcResponse.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }
}

// *********************************************************************
// WEBRPC-DART HELPER CODE.
// *********************************************************************

String _removeSlash(String host) => host.endsWith('/')
    ? host.replaceRange(host.length - 1, host.length, '')
    : host;

const Set<int> _nonErrorcodes = {
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  300,
  301,
  302,
  303,
  304,
  307,
  308,
};

// An http error.
class _HttpErr {
  final String status;
  final int code;
  const _HttpErr(this.status, this.code);

  Map<String, dynamic> toMap() => {'status': status, 'code': code};
  String toJson() => jsonEncode(toMap());
  static _HttpErr fromMap(Map<String, dynamic> map) =>
      _HttpErr(map['status'] as String, map['code'] as int);

  static _HttpErr fromJson(dynamic json) => fromMap(
        jsonDecode(json),
      );
}

// An error created by the rpc server.
class _RpcErr {
  final String message;
  final String path;
  final DateTime time;
  final _HttpErr httpErr;
  const _RpcErr({this.message, this.path, this.httpErr, this.time});
  static const _RpcErr unknown = _RpcErr(
      message: 'an unknown error has occured',
      path: 'unknown',
      httpErr: _HttpErr('unknown', 400),
      time: null);
  Map<String, dynamic> toMap() => {
        'message': message,
        'path': path,
        'httpErr': httpErr.toMap(),
        'time-stamp': time.toString()
      };
  String toJson() => jsonEncode(toMap());
  static _RpcErr fromMap(Map<String, dynamic> map) => _RpcErr(
        message: map['message'] as String,
        path: map['path'] as String,
        time: DateTime.parse(
          map['time-stamp'],
        ),
        httpErr: _HttpErr.fromMap(
          map['httpErr'],
        ),
      );
  static _RpcErr fromJson(dynamic json) => fromMap(
        jsonDecode(json),
      );
}
