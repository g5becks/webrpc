import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:http/http.dart' as http;
import 'package:meta/meta.dart';

part 'example_service.freezed.dart';
part 'example_service.g.dart';

// example v0.0.1 297cedbc91660c3155f254892772490bc0522641
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/dart
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
String webRPCVersion() {
  return "v1";
}

// Schema version of your RIDL schema
String WebRPCSchemaVersion() {
  return "v0.0.1";
}

// Schema hash generated from your RIDL schema
String WebRPCSchemaHash() {
  return "297cedbc91660c3155f254892772490bc0522641";
}

// **********************************************************************
// MESSAGE TYPES.
// **********************************************************************
@freezed
abstract class Kind with _$Kind {
  const factory Kind.user() = USER;
  const factory Kind.admin() = ADMIN;
  factory Kind.fromJson(Map<String, dynamic> json) => _$KindFromJson(json);
}

@freezed
abstract class Empty with _$Empty {
  factory Empty() = _Empty;
  factory Empty.fromJson(Map<String, dynamic> json) => _$EmptyFromJson(json);
}

@freezed
abstract class User with _$User {
  factory User({
    @required int id,
    @JsonKey(name: 'USERNAME') @required String username,
    @required String role,
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

@freezed
abstract class SearchFilter with _$SearchFilter {
  factory SearchFilter({
    @required String q,
  }) = _SearchFilter;
  factory SearchFilter.fromJson(Map<String, dynamic> json) =>
      _$SearchFilterFromJson(json);
}

@freezed
abstract class Version with _$Version {
  factory Version({
    @required String webrpcVersion,
    @required String schemaVersion,
    @required String schemaHash,
  }) = _Version;
  factory Version.fromJson(Map<String, dynamic> json) =>
      _$VersionFromJson(json);
}

@freezed
abstract class ComplexType with _$ComplexType {
  factory ComplexType({
    @required Map<String, dynamic> meta,
    @required Map<String, Map<String, int>> metaNestedExample,
    @required List<String> namesList,
    @required List<int> numsList,
    @required List<List<String>> doubleArray,
    @required List<User> listOfUsers,
    @required Map<String, User> mapOfUsers,
    @required User user,
    List<Map<String, int>> listOfMaps,
  }) = _ComplexType;
  factory ComplexType.fromJson(Map<String, dynamic> json) =>
      _$ComplexTypeFromJson(json);
}

// *********************************************************************
// ExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class _ExampleServiceGetUserArgs with _$_ExampleServiceGetUserArgs {
  factory _ExampleServiceGetUserArgs({
    @required Map<String, String> header,
    @required int userID,
  }) = _ExampleServiceGetUserArgs_Freezed;
  factory _ExampleServiceGetUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_ExampleServiceGetUserArgsFromJson(json);
}

@freezed
abstract class _ExampleServiceFindUserArgs with _$_ExampleServiceFindUserArgs {
  factory _ExampleServiceFindUserArgs({
    @required SearchFilter s,
  }) = _ExampleServiceFindUserArgs_Freezed;
  factory _ExampleServiceFindUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_ExampleServiceFindUserArgsFromJson(json);
}

// *********************************************************************
// ExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class StatusResult with _$StatusResult {
  factory StatusResult.data({
    @required bool status,
  }) = _StatusResult;

  factory StatusResult.failed({
    @required int statusCode,
    @required String reason,
    String stackTrace,
  }) = _StatusResultFailed;
  const factory StatusResult.pending() = _StatusResultPending;

  factory StatusResult.fromJson(Map<String, dynamic> json) =>
      _$StatusResultFromJson(json);
}

@freezed
abstract class VersionResult with _$VersionResult {
  factory VersionResult.data({
    @required Version version,
  }) = _VersionResult;

  factory VersionResult.failed({
    @required int statusCode,
    @required String reason,
    String stackTrace,
  }) = _VersionResultFailed;
  const factory VersionResult.pending() = _VersionResultPending;

  factory VersionResult.fromJson(Map<String, dynamic> json) =>
      _$VersionResultFromJson(json);
}

@freezed
abstract class GetUserResult with _$GetUserResult {
  factory GetUserResult.data({
    @required int code,
    @required User user,
  }) = _GetUserResult;

  factory GetUserResult.failed({
    @required int statusCode,
    @required String reason,
    String stackTrace,
  }) = _GetUserResultFailed;
  const factory GetUserResult.pending() = _GetUserResultPending;

  factory GetUserResult.fromJson(Map<String, dynamic> json) =>
      _$GetUserResultFromJson(json);
}

@freezed
abstract class FindUserResult with _$FindUserResult {
  factory FindUserResult.data({
    @required String name,
    @required User user,
  }) = _FindUserResult;

  factory FindUserResult.failed({
    @required int statusCode,
    @required String reason,
    String stackTrace,
  }) = _FindUserResultFailed;
  const factory FindUserResult.pending() = _FindUserResultPending;

  factory FindUserResult.fromJson(Map<String, dynamic> json) =>
      _$FindUserResultFromJson(json);
}

// *********************************************************************
// AnotherExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class _AnotherExampleServiceGetAccountArgs
    with _$_AnotherExampleServiceGetAccountArgs {
  factory _AnotherExampleServiceGetAccountArgs({
    @required Map<String, String> header,
    @required int userID,
  }) = _AnotherExampleServiceGetAccountArgs_Freezed;
  factory _AnotherExampleServiceGetAccountArgs.fromJson(
          Map<String, dynamic> json) =>
      _$_AnotherExampleServiceGetAccountArgsFromJson(json);
}

@freezed
abstract class _AnotherExampleServiceGetUsersArgs
    with _$_AnotherExampleServiceGetUsersArgs {
  factory _AnotherExampleServiceGetUsersArgs({
    @required SearchFilter s,
  }) = _AnotherExampleServiceGetUsersArgs_Freezed;
  factory _AnotherExampleServiceGetUsersArgs.fromJson(
          Map<String, dynamic> json) =>
      _$_AnotherExampleServiceGetUsersArgsFromJson(json);
}

// *********************************************************************
// AnotherExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class AnotherExampleServiceStatusResult
    with _$AnotherExampleServiceStatusResult {
  factory AnotherExampleServiceStatusResult.data({
    @required bool status,
  }) = _AnotherExampleServiceStatusResult;

  factory AnotherExampleServiceStatusResult.failed({
    @required int statusCode,
    @required String reason,
    String stackTrace,
  }) = _AnotherExampleServiceStatusResultFailed;
  const factory AnotherExampleServiceStatusResult.pending() =
      _AnotherExampleServiceStatusResultPending;

  factory AnotherExampleServiceStatusResult.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceStatusResultFromJson(json);
}

@freezed
abstract class GetVersionResult with _$GetVersionResult {
  factory GetVersionResult.data({
    @required Version version,
  }) = _GetVersionResult;

  factory GetVersionResult.failed({
    @required int statusCode,
    @required String reason,
    String stackTrace,
  }) = _GetVersionResultFailed;
  const factory GetVersionResult.pending() = _GetVersionResultPending;

  factory GetVersionResult.fromJson(Map<String, dynamic> json) =>
      _$GetVersionResultFromJson(json);
}

@freezed
abstract class GetAccountResult with _$GetAccountResult {
  factory GetAccountResult.data({
    @required int code,
    @required User user,
  }) = _GetAccountResult;

  factory GetAccountResult.failed({
    @required int statusCode,
    @required String reason,
    String stackTrace,
  }) = _GetAccountResultFailed;
  const factory GetAccountResult.pending() = _GetAccountResultPending;

  factory GetAccountResult.fromJson(Map<String, dynamic> json) =>
      _$GetAccountResultFromJson(json);
}

@freezed
abstract class GetUsersResult with _$GetUsersResult {
  factory GetUsersResult.data({
    @required String name,
    @required User user,
  }) = _GetUsersResult;

  factory GetUsersResult.failed({
    @required int statusCode,
    @required String reason,
    String stackTrace,
  }) = _GetUsersResultFailed;
  const factory GetUsersResult.pending() = _GetUsersResultPending;

  factory GetUsersResult.fromJson(Map<String, dynamic> json) =>
      _$GetUsersResultFromJson(json);
}

// ***********************************************************************
// WEBRPC-DART SERVICE CLIENTS.
// ***********************************************************************

String _removeSlash(String host) => host.endsWith('/')
    ? host.replaceRange(host.length - 1, host.length, '')
    : host;

class ExampleService {
  final String host;
  String _srvcPath = '/rpc/ExampleService/';
  ExampleService({
    this.host = 'localhost',
  }) {
    _srvcPath = '${_removeSlash(host)}/rpc/ExampleService/';
  }

  Future<http.Response> _makeRequest(
    String route, {
    dynamic json = "{}",
    Map<String, String> headers,
  }) {
    final path = '$_srvcPath/$route';
    return http.post(path,
        headers: {
          ...?headers,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: json);
  }

  _RpcErr _getErr(http.Response r) {
    try {
      return _RpcErr.fromJson(jsonDecode(r.body));
    } on Exception catch (_) {
      return _RpcErr.unknown;
    }
  }

  FutureOr<void> ping({
    Map<String, String> headers,
  }) async {}

  Stream<StatusResult> status({
    Map<String, String> headers,
  }) async* {
    const num = 0;
    while (num == 0) {
      yield const StatusResult.pending();
      try {
        final http.Response response = await _makeRequest(
          'Status',
          json: jsonEncode("{}"),
          headers: headers,
        );

        if (!_nonErrorcodes.contains(response.statusCode)) {
          final _RpcErr err = _getErr(response);
          yield StatusResult.failed(
            reason: err.message,
            statusCode: err.httpErr.code,
          );
          break;
        }
        yield StatusResult.fromJson(
          jsonDecode(
            response.body,
          ),
        );
        break;
      } on Exception catch (e, stackTrace) {
        yield StatusResult.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }
  }

  Stream<VersionResult> version({
    Map<String, String> headers,
  }) async* {
    const num = 0;
    while (num == 0) {
      yield const VersionResult.pending();
      try {
        final http.Response response = await _makeRequest(
          'Version',
          json: jsonEncode("{}"),
          headers: headers,
        );

        if (!_nonErrorcodes.contains(response.statusCode)) {
          final _RpcErr err = _getErr(response);
          yield VersionResult.failed(
            reason: err.message,
            statusCode: err.httpErr.code,
          );
          break;
        }
        yield VersionResult.fromJson(
          jsonDecode(
            response.body,
          ),
        );
        break;
      } on Exception catch (e, stackTrace) {
        yield VersionResult.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }
  }

  Stream<GetUserResult> getUser({
    @required Map<String, String> header,
    @required int userID,
    Map<String, String> headers,
  }) async* {
    const num = 0;
    while (num == 0) {
      yield GetUserResult.pending();
      try {
        final _ExampleServiceGetUserArgs args = _ExampleServiceGetUserArgs(
          header: header,
          userID: userID,
        );

        final http.Response response = await _makeRequest(
          'GetUser',
          json: jsonEncode(args.toJson()),
          headers: headers,
        );

        if (!_nonErrorcodes.contains(response.statusCode)) {
          final _RpcErr err = _getErr(response);
          yield GetUserResult.failed(
            reason: err.message,
            statusCode: err.httpErr.code,
          );
          break;
        }
        yield GetUserResult.fromJson(
          jsonDecode(
            response.body,
          ),
        );
        break;
      } on Exception catch (e, stackTrace) {
        yield GetUserResult.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }
  }

  Stream<FindUserResult> findUser({
    @required SearchFilter s,
    Map<String, String> headers,
  }) async* {
    const num = 0;
    while (num == 0) {
      yield FindUserResult.pending();
      try {
        final _ExampleServiceFindUserArgs args = _ExampleServiceFindUserArgs(
          s: s,
        );

        final http.Response response = await _makeRequest(
          'FindUser',
          json: jsonEncode(args.toJson()),
          headers: headers,
        );

        if (!_nonErrorcodes.contains(response.statusCode)) {
          final _RpcErr err = _getErr(response);
          yield FindUserResult.failed(
            reason: err.message,
            statusCode: err.httpErr.code,
          );
          break;
        }
        yield FindUserResult.fromJson(
          jsonDecode(
            response.body,
          ),
        );
        break;
      } on Exception catch (e, stackTrace) {
        yield FindUserResult.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }
  }
}

class AnotherExampleService {
  final String host;
  String _srvcPath = '/rpc/AnotherExampleService/';
  AnotherExampleService({
    this.host = 'localhost',
  }) {
    _srvcPath = '${_removeSlash(host)}/rpc/AnotherExampleService/';
  }

  Future<http.Response> _makeRequest(
    String route, {
    dynamic json = "{}",
    Map<String, String> headers,
  }) {
    final path = '$_srvcPath/$route';
    return http.post(path,
        headers: {
          ...?headers,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: json);
  }

  _RpcErr _getErr(http.Response r) {
    try {
      return _RpcErr.fromJson(jsonDecode(r.body));
    } on Exception catch (_) {
      return _RpcErr.unknown;
    }
  }

  FutureOr<void> pingServer({
    Map<String, String> headers,
  }) async {}

  Stream<AnotherExampleServiceStatusResult> status({
    Map<String, String> headers,
  }) async* {
    const num = 0;
    while (num == 0) {
      yield AnotherExampleServiceStatusResult.pending();
      try {
        final http.Response response = await _makeRequest(
          'Status',
          json: jsonEncode("{}"),
          headers: headers,
        );

        if (!_nonErrorcodes.contains(response.statusCode)) {
          final _RpcErr err = _getErr(response);
          yield AnotherExampleServiceStatusResult.failed(
            reason: err.message,
            statusCode: err.httpErr.code,
          );
          break;
        }
        yield AnotherExampleServiceStatusResult.fromJson(
          jsonDecode(
            response.body,
          ),
        );
        break;
      } on Exception catch (e, stackTrace) {
        yield AnotherExampleServiceStatusResult.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }
  }

  Stream<GetVersionResult> getVersion({
    Map<String, String> headers,
  }) async* {
    const num = 0;
    while (num == 0) {
      yield GetVersionResult.pending();
      try {
        final http.Response response = await _makeRequest(
          'GetVersion',
          json: jsonEncode("{}"),
          headers: headers,
        );

        if (!_nonErrorcodes.contains(response.statusCode)) {
          final _RpcErr err = _getErr(response);
          yield GetVersionResult.failed(
            reason: err.message,
            statusCode: err.httpErr.code,
          );
          break;
        }
        yield GetVersionResult.fromJson(
          jsonDecode(
            response.body,
          ),
        );
        break;
      } on Exception catch (e, stackTrace) {
        yield GetVersionResult.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }
  }

  Stream<GetAccountResult> getAccount({
    @required Map<String, String> header,
    @required int userID,
    Map<String, String> headers,
  }) async* {
    const num = 0;
    while (num == 0) {
      yield GetAccountResult.pending();
      try {
        final _AnotherExampleServiceGetAccountArgs args =
            _AnotherExampleServiceGetAccountArgs(
          header: header,
          userID: userID,
        );

        final http.Response response = await _makeRequest(
          'GetAccount',
          json: jsonEncode(args.toJson()),
          headers: headers,
        );

        if (!_nonErrorcodes.contains(response.statusCode)) {
          final _RpcErr err = _getErr(response);
          yield GetAccountResult.failed(
            reason: err.message,
            statusCode: err.httpErr.code,
          );
          break;
        }
        yield GetAccountResult.fromJson(
          jsonDecode(
            response.body,
          ),
        );
        break;
      } on Exception catch (e, stackTrace) {
        yield GetAccountResult.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }
  }

  Stream<GetUsersResult> getUsers({
    @required SearchFilter s,
    Map<String, String> headers,
  }) async* {
    const num = 0;
    while (num == 0) {
      yield GetUsersResult.pending();
      try {
        final _AnotherExampleServiceGetUsersArgs args =
            _AnotherExampleServiceGetUsersArgs(
          s: s,
        );

        final http.Response response = await _makeRequest(
          'GetUsers',
          json: jsonEncode(args.toJson()),
          headers: headers,
        );

        if (!_nonErrorcodes.contains(response.statusCode)) {
          final _RpcErr err = _getErr(response);
          yield GetUsersResult.failed(
            reason: err.message,
            statusCode: err.httpErr.code,
          );
          break;
        }
        yield GetUsersResult.fromJson(
          jsonDecode(
            response.body,
          ),
        );
        break;
      } on Exception catch (e, stackTrace) {
        yield GetUsersResult.failed(
          statusCode: 400,
          reason: e.toString(),
          stackTrace: stackTrace.toString(),
        );
        break;
      }
    }
  }
}

// *********************************************************************
// WEBRPC-DART HELPER CODE.
// *********************************************************************

const Set<int> _nonErrorcodes = {
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  300,
  301,
  302,
  303,
  304,
  307,
  308,
};

// An http error.
class _HttpErr {
  final String status;
  final int code;
  const _HttpErr(this.status, this.code);

  Map<String, dynamic> toMap() => {'status': status, 'code': code};
  String toJson() => jsonEncode(toMap());
  static _HttpErr fromMap(Map<String, dynamic> map) =>
      _HttpErr(map['status'] as String, map['code'] as int);

  static _HttpErr fromJson(dynamic json) => fromMap(jsonDecode(json));
}

// An error created by the rpc server.
class _RpcErr {
  final String message;
  final String path;
  final DateTime time;
  final _HttpErr httpErr;
  const _RpcErr({this.message, this.path, this.httpErr, this.time});
  static const _RpcErr unknown = _RpcErr(
      message: 'an unknown error has occured',
      path: 'unknown',
      httpErr: _HttpErr('unknown', 400),
      time: null);
  Map<String, dynamic> toMap() => {
        'message': message,
        'path': path,
        'httpErr': httpErr.toMap(),
        'time-stamp': time.toString()
      };
  String toJson() => jsonEncode(toMap());
  static _RpcErr fromMap(Map<String, dynamic> map) => _RpcErr(
      message: map['message'] as String,
      path: map['path'] as String,
      time: DateTime.parse(map['time-stamp']),
      httpErr: _HttpErr.fromMap(map['httpErr']));
  static _RpcErr fromJson(dynamic json) => fromMap(jsonDecode(json));
}
