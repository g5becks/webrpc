import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

import 'package:flutter/foundation.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:http/http.dart' as http;
import 'package:http_parser/http_parser.dart';
import 'package:meta/meta.dart';

part 'client.freezed.dart';
part 'client.g.dart';

// example v0.0.1 ebe26b74a56342a2fb2bf54ac0c0b43300a257b0
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/dart
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
String webRPCVersion() {
  return "v1";
}

// Schema version of your RIDL schema
String WebRPCSchemaVersion() {
  return "v0.0.1";
}

// Schema hash generated from your RIDL schema
String WebRPCSchemaHash() {
  return "ebe26b74a56342a2fb2bf54ac0c0b43300a257b0";
}

// **********************************************************************
// MESSAGE TYPES.
// **********************************************************************
@freezed
abstract class Kind with _$Kind {
  const factory Kind.user() = USER;
  const factory Kind.admin() = ADMIN;
  factory Kind.fromJson(Map<String, dynamic> json) => _$KindFromJson(json);
}

@freezed
abstract class Empty with _$Empty {
  const factory Empty() = _Empty;
  factory Empty.fromJson(Map<String, dynamic> json) => _$EmptyFromJson(json);
}

@freezed
abstract class User with _$User {
  @JsonSerializable(explicitToJson: true)
  const factory User({
    @required int id,
    @required @JsonKey(name: 'USERNAME') String username,
    @required String role,
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

@freezed
abstract class SearchFilter with _$SearchFilter {
  const factory SearchFilter({
    @required String q,
  }) = _SearchFilter;
  factory SearchFilter.fromJson(Map<String, dynamic> json) =>
      _$SearchFilterFromJson(json);
}

@freezed
abstract class Version with _$Version {
  const factory Version({
    @required String webrpcVersion,
    @required String schemaVersion,
    @required String schemaHash,
  }) = _Version;
  factory Version.fromJson(Map<String, dynamic> json) =>
      _$VersionFromJson(json);
}

@freezed
abstract class ComplexType with _$ComplexType {
  const factory ComplexType({
    @required Map<String, dynamic> meta,
    @required Map<String, Map<String, int>> metaNestedExample,
    @required List<String> namesList,
    @required List<int> numsList,
    @required List<List<String>> doubleArray,
    @required List<User> listOfUsers,
    @required Map<String, User> mapOfUsers,
    @required User user,
    List<Map<String, int>> listOfMaps,
  }) = _ComplexType;
  factory ComplexType.fromJson(Map<String, dynamic> json) =>
      _$ComplexTypeFromJson(json);
}

// *********************************************************************
// ExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class ExampleServiceGetUserArgs with _$ExampleServiceGetUserArgs {
  const factory ExampleServiceGetUserArgs({
    @required Map<String, String> header,
    @required int userID,
  }) = _ExampleServiceGetUserArgs;
  factory ExampleServiceGetUserArgs.fromJson(Map<String, dynamic> json) =>
      _$ExampleServiceGetUserArgsFromJson(json);
}

@freezed
abstract class ExampleServiceFindUserArgs with _$ExampleServiceFindUserArgs {
  const factory ExampleServiceFindUserArgs({
    @required SearchFilter s,
  }) = _ExampleServiceFindUserArgs;
  factory ExampleServiceFindUserArgs.fromJson(Map<String, dynamic> json) =>
      _$ExampleServiceFindUserArgsFromJson(json);
}

// *********************************************************************
// ExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class ExampleServiceStatusReturn with _$ExampleServiceStatusReturn {
  const factory ExampleServiceStatusReturn({
    @required bool status,
  }) = _ExampleServiceStatusReturn;
  factory ExampleServiceStatusReturn.fromJson(Map<String, dynamic> json) =>
      _$ExampleServiceStatusReturnFromJson(json);
}

@freezed
abstract class ExampleServiceVersionReturn with _$ExampleServiceVersionReturn {
  const factory ExampleServiceVersionReturn({
    @required Version version,
  }) = _ExampleServiceVersionReturn;
  factory ExampleServiceVersionReturn.fromJson(Map<String, dynamic> json) =>
      _$ExampleServiceVersionReturnFromJson(json);
}

@freezed
abstract class ExampleServiceGetUserReturn with _$ExampleServiceGetUserReturn {
  const factory ExampleServiceGetUserReturn({
    @required int code,
    @required User user,
  }) = _ExampleServiceGetUserReturn;
  factory ExampleServiceGetUserReturn.fromJson(Map<String, dynamic> json) =>
      _$ExampleServiceGetUserReturnFromJson(json);
}

@freezed
abstract class ExampleServiceFindUserReturn
    with _$ExampleServiceFindUserReturn {
  const factory ExampleServiceFindUserReturn({
    @required String name,
    @required User user,
  }) = _ExampleServiceFindUserReturn;
  factory ExampleServiceFindUserReturn.fromJson(Map<String, dynamic> json) =>
      _$ExampleServiceFindUserReturnFromJson(json);
}

// *********************************************************************
// AnotherExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class AnotherExampleServiceGetUserArgs
    with _$AnotherExampleServiceGetUserArgs {
  const factory AnotherExampleServiceGetUserArgs({
    @required Map<String, String> header,
    @required int userID,
  }) = _AnotherExampleServiceGetUserArgs;
  factory AnotherExampleServiceGetUserArgs.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceGetUserArgsFromJson(json);
}

@freezed
abstract class AnotherExampleServiceFindUserArgs
    with _$AnotherExampleServiceFindUserArgs {
  const factory AnotherExampleServiceFindUserArgs({
    @required SearchFilter s,
  }) = _AnotherExampleServiceFindUserArgs;
  factory AnotherExampleServiceFindUserArgs.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceFindUserArgsFromJson(json);
}

// *********************************************************************
// AnotherExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class AnotherExampleServiceStatusReturn
    with _$AnotherExampleServiceStatusReturn {
  const factory AnotherExampleServiceStatusReturn({
    @required bool status,
  }) = _AnotherExampleServiceStatusReturn;
  factory AnotherExampleServiceStatusReturn.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceStatusReturnFromJson(json);
}

@freezed
abstract class AnotherExampleServiceVersionReturn
    with _$AnotherExampleServiceVersionReturn {
  const factory AnotherExampleServiceVersionReturn({
    @required Version version,
  }) = _AnotherExampleServiceVersionReturn;
  factory AnotherExampleServiceVersionReturn.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceVersionReturnFromJson(json);
}

@freezed
abstract class AnotherExampleServiceGetUserReturn
    with _$AnotherExampleServiceGetUserReturn {
  const factory AnotherExampleServiceGetUserReturn({
    @required int code,
    @required User user,
  }) = _AnotherExampleServiceGetUserReturn;
  factory AnotherExampleServiceGetUserReturn.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceGetUserReturnFromJson(json);
}

@freezed
abstract class AnotherExampleServiceFindUserReturn
    with _$AnotherExampleServiceFindUserReturn {
  const factory AnotherExampleServiceFindUserReturn({
    @required String name,
    @required User user,
  }) = _AnotherExampleServiceFindUserReturn;
  factory AnotherExampleServiceFindUserReturn.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceFindUserReturnFromJson(json);
}

// ***********************************************************************
// WEBRPC-DART SERVICE CLIENTS.
// ***********************************************************************

/// Converts [input] into a [Uint8List].
///
/// If [input] is a [TypedData], this just returns a view on [input].
Uint8List toUint8List(List<int> input) {
  if (input is Uint8List) return input;
  if (input is TypedData) {
    return Uint8List.view((input as TypedData).buffer);
  }
  return Uint8List.fromList(input);
}

/// Returns the [Encoding] that corresponds to [charset].
///
/// Throws a [FormatException] if no [Encoding] was found that corresponds to
/// [charset].
///
/// [charset] may not be null.
Encoding requiredEncodingForCharset(String charset) =>
    Encoding.getByName(charset) ??
    (throw FormatException('Unsupported encoding "$charset".'));

/// Converts a [Map] from parameter names to values to a URL query string.
///
///     mapToQuery({"foo": "bar", "baz": "bang"});
///     //=> "foo=bar&baz=bang"
String mapToQuery(Map<String, String> map, {Encoding encoding}) {
  var pairs = <List<String>>[];
  map.forEach((key, value) => pairs.add([
        Uri.encodeQueryComponent(key, encoding: encoding),
        Uri.encodeQueryComponent(value, encoding: encoding)
      ]));
  return pairs.map((pair) => '${pair[0]}=${pair[1]}').join('&');
}

/// An HTTP request where the entire request body is known in advance.
class Request extends http.BaseRequest {
  /// The size of the request body, in bytes. This is calculated from
  /// [bodyBytes].
  ///
  /// The content length cannot be set for [Request], since it's automatically
  /// calculated from [bodyBytes].
  @override
  int get contentLength => bodyBytes.length;

  @override
  set contentLength(int value) {
    throw UnsupportedError('Cannot set the contentLength property of '
        'non-streaming Request objects.');
  }

  /// The default encoding to use when converting between [bodyBytes] and
  /// [body].
  ///
  /// This is only used if [encoding] hasn't been manually set and if the
  /// content-type header has no encoding information.
  Encoding _defaultEncoding;

  /// The encoding used for the request.
  ///
  /// This encoding is used when converting between [bodyBytes] and [body].
  ///
  /// If the request has a `Content-Type` header and that header has a `charset`
  /// parameter, that parameter's value is used as the encoding. Otherwise, if
  /// [encoding] has been set manually, that encoding is used. If that hasn't
  /// been set either, this defaults to [utf8].
  ///
  /// If the `charset` parameter's value is not a known [Encoding], reading this
  /// will throw a [FormatException].
  ///
  /// If the request has a `Content-Type` header, setting this will set the
  /// charset parameter on that header.
  Encoding get encoding {
    if (_contentType == null ||
        !_contentType.parameters.containsKey('charset')) {
      return _defaultEncoding;
    }
    return requiredEncodingForCharset(_contentType.parameters['charset']);
  }

  set encoding(Encoding value) {
    _checkFinalized();
    _defaultEncoding = value;
    var contentType = _contentType;
    if (contentType == null) return;
    _contentType = contentType.change(parameters: {'charset': value.name});
  }

  // TODO(nweiz): make this return a read-only view
  /// The bytes comprising the body of the request.
  ///
  /// This is converted to and from [body] using [encoding].
  ///
  /// This list should only be set, not be modified in place.
  Uint8List get bodyBytes => _bodyBytes;
  Uint8List _bodyBytes;

  set bodyBytes(List<int> value) {
    _checkFinalized();
    _bodyBytes = toUint8List(value);
  }

  /// The body of the request as a string.
  ///
  /// This is converted to and from [bodyBytes] using [encoding].
  ///
  /// When this is set, if the request does not yet have a `Content-Type`
  /// header, one will be added with the type `text/plain`. Then the `charset`
  /// parameter of the `Content-Type` header (whether new or pre-existing) will
  /// be set to [encoding] if it wasn't already set.
  String get body => encoding.decode(bodyBytes);

  set body(String value) {
    bodyBytes = encoding.encode(value);
    var contentType = _contentType;
    if (contentType == null) {
      _contentType = MediaType('text', 'plain', {'charset': encoding.name});
    } else if (!contentType.parameters.containsKey('charset')) {
      _contentType = contentType.change(parameters: {'charset': encoding.name});
    }
  }

  /// The form-encoded fields in the body of the request as a map from field
  /// names to values.
  ///
  /// The form-encoded body is converted to and from [bodyBytes] using
  /// [encoding] (in the same way as [body]).
  ///
  /// If the request doesn't have a `Content-Type` header of
  /// `application/x-www-form-urlencoded`, reading this will throw a
  /// [StateError].
  ///
  /// If the request has a `Content-Type` header with a type other than
  /// `application/x-www-form-urlencoded`, setting this will throw a
  /// [StateError]. Otherwise, the content type will be set to
  /// `application/x-www-form-urlencoded`.
  ///
  /// This map should only be set, not modified in place.
  Map<String, String> get bodyFields {
    var contentType = _contentType;
    if (contentType == null ||
        contentType.mimeType != 'application/x-www-form-urlencoded') {
      throw StateError('Cannot access the body fields of a Request without '
          'content-type "application/x-www-form-urlencoded".');
    }

    return Uri.splitQueryString(body, encoding: encoding);
  }

  set bodyFields(Map<String, String> fields) {
    var contentType = _contentType;
    if (contentType == null) {
      _contentType = MediaType('application', 'x-www-form-urlencoded');
    } else if (contentType.mimeType != 'application/x-www-form-urlencoded') {
      throw StateError('Cannot set the body fields of a Request with '
          'content-type "${contentType.mimeType}".');
    }

    body = mapToQuery(fields, encoding: encoding);
  }

  Request(String method, Uri url)
      : _defaultEncoding = utf8,
        _bodyBytes = Uint8List(0),
        super(method, url);

  /// Freezes all mutable fields and returns a single-subscription [ByteStream]
  /// containing the request body.
  @override
  http.ByteStream finalize() {
    super.finalize();
    return http.ByteStream.fromBytes(bodyBytes);
  }

  /// The `Content-Type` header of the request (if it exists) as a [MediaType].
  MediaType get _contentType {
    var contentType = headers['content-type'];
    if (contentType == null) return null;
    return MediaType.parse(contentType);
  }

  set _contentType(MediaType value) {
    headers['content-type'] = value.toString();
  }

  /// Throw an error if this request has been finalized.
  void _checkFinalized() {
    if (!finalized) return;
    throw StateError("Can't modify a finalized Request.");
  }
}

String _removeSlash(String host) => host.endsWith('/')
    ? host.replaceRange(host.length - 1, host.length, '')
    : host;

class ExampleService {
  final http.Client client;
  final String host;
  RpcLogger _log;
  String _srvcPath = '/rpc/ExampleService/';
  String _url(String route) => '$_srvcPath$route';
  ExampleService({
    @required this.client,
    this.host = 'localhost',
    RpcLogger logger,
  }) {
    _srvcPath = '${_removeSlash(host)}/rpc/ExampleService/';
    _log = logger ?? _rpcLogger;
  }

  http.Request _createRequest() {
    http.Request r = http.Request('POST', Uri());
    r.headers = {};
  }

  FutureOr<void> ping({Map<String, String> headers}) async {}

  FutureOr<ExampleServiceStatusReturn> status(
      {Map<String, String> headers}) async {}

  FutureOr<ExampleServiceVersionReturn> version(
      {Map<String, String> headers}) async {}

  FutureOr<ExampleServiceGetUserReturn> getUser(
      {@required ExampleServiceGetUserArgs args,
      Map<String, String> headers}) async {}

  FutureOr<ExampleServiceFindUserReturn> findUser(
      {@required ExampleServiceFindUserArgs args,
      Map<String, String> headers}) async {}
}

class AnotherExampleService {
  final http.Client client;
  final String host;
  RpcLogger _log;
  String _srvcPath = '/rpc/AnotherExampleService/';
  AnotherExampleService({
    @required this.client,
    this.host = 'localhost',
    RpcLogger logger,
  }) {
    _srvcPath = '${_removeSlash(host)}/rpc/AnotherExampleService/';
    _log = logger ?? _rpcLogger;
  }

  FutureOr<void> ping({Map<String, String> headers}) async {}

  FutureOr<AnotherExampleServiceStatusReturn> status(
      {Map<String, String> headers}) async {}

  FutureOr<AnotherExampleServiceVersionReturn> version(
      {Map<String, String> headers}) async {}

  FutureOr<AnotherExampleServiceGetUserReturn> getUser(
      {@required AnotherExampleServiceGetUserArgs args,
      Map<String, String> headers}) async {}

  FutureOr<AnotherExampleServiceFindUserReturn> findUser(
      {@required AnotherExampleServiceFindUserArgs args,
      Map<String, String> headers}) async {}
}

// *********************************************************************
// WEBRPC-DART HELPER CODE.
// *********************************************************************

String _logMsg(Exception exc, [Object error, StackTrace stackTrace]) =>
    '{message: ${exc.toString()}, timeStamp: ${DateTime.now().toString()}, error: $error, stackTrace: $stackTrace}';

void _logExc(RpcLogger log, Exception exc,
        [Object error, StackTrace stackTrace]) =>
    log.warning(_logMsg(exc, error, stackTrace));

abstract class RpcLogger {
  void _log(message, [Object error, StackTrace stackTrace]) => print(
      '{message: $message}, error: $error, stackTrace: $stackTrace, time: ${DateTime.now()}');
  void finest(message, [Object error, StackTrace stackTrace]) =>
      _log(message, error, stackTrace);
  void finer(message, [Object error, StackTrace stackTrace]) =>
      _log(message, error, stackTrace);
  void fine(message, [Object error, StackTrace stackTrace]) =>
      _log(message, error, stackTrace);
  void config(message, [Object error, StackTrace stackTrace]) =>
      _log(message, error, stackTrace);
  void info(message, [Object error, StackTrace stackTrace]) =>
      _log(message, error, stackTrace);
  void warning(message, [Object error, StackTrace stackTrace]) =>
      _log(message, error, stackTrace);
  void severe(message, [Object error, StackTrace stackTrace]) =>
      _log(message, error, stackTrace);
  void shout(message, [Object error, StackTrace stackTrace]) =>
      _log(message, error, stackTrace);
}

class _Logger extends RpcLogger {
  _Logger();
}

final _rpcLogger = _Logger();

// An error in the http stack.
class HttpErr {
  final String status;
  final int code;
  const HttpErr(this.status, this.code);

  Map<String, dynamic> toMap() => {'status': status, 'code': code};
  String toJson() => jsonEncode(toMap());
  static HttpErr fromMap(Map<String, dynamic> map) =>
      HttpErr(map['status'] as String, map['code'] as int);

  static HttpErr fromJson(json) => fromMap(jsonDecode(json));
}

// An error created by the rpc server.
class RpcErr {
  final String message;
  final String path;
  final DateTime time;
  final HttpErr httpErr;
  const RpcErr({this.message, this.path, this.httpErr, this.time});

  Map<String, dynamic> toMap() => {
        'message': message,
        'path': path,
        'httpErr': httpErr.toMap(),
        'time-stamp': time.toString()
      };
  String toJson() => jsonEncode(toMap());
  static RpcErr fromMap(Map<String, dynamic> map) => RpcErr(
      message: map['message'] as String,
      path: map['path'] as String,
      time: DateTime.parse(map['time-stamp']),
      httpErr: HttpErr.fromMap(map['httpErr']));
  static RpcErr fromJson(json) => fromMap(jsonDecode(json));
}

// Contains static fields for creating and identifying http errors.
class err {
  // Unknown error. For example when handling errors raised by APIs that do not
  // return enough error information.
  static HttpErr Unknown = HttpErr('unknown', 400);
  // 422 (Unprocessable Entity) Fail error. General failure error type.
  static HttpErr Fail = HttpErr('fail', 422);
  // RequestTimeout Canceled indicates the operation was cancelled (typically by the caller).
  static HttpErr Canceled = HttpErr('canceled', 408);
  // InvalidArgument indicates client specified an invalid argument. It
  // indicates arguments that are problematic regardless of the state of the
  // system (i.e. a malformed file name, required argument, number out of range,
  // etc.).
  static HttpErr InvalidArgument = HttpErr('invalid argument', 422);
  // RequestTimeOut. DeadlineExceeded means operation expired before completion. For operations
  // that change the state of the system, this error may be returned even if the
  // operation has completed successfully (timeout).
  static HttpErr DeadlineExceeded = HttpErr('deadline exceeded', 408);
  // NotFound means some requested entity was not found.
  static HttpErr NotFound = HttpErr('not found', 404);
  // BadRoute means that the requested URL path wasn't routable to a webrpc
  // service and method. This is returned by the generated server, and usually
  // shouldn't be returned by applications. Instead, applications should use
  // NotFound or Unimplemented.
  static HttpErr BadRoute = HttpErr('bad route', 404);
  // AlreadyExists means an attempt to create an entity failed because one
  // already exists. Conflict.
  static HttpErr AlreadyExists = HttpErr('already exists', 409);
  // PermissionDenied indicates the caller does not have permission to execute
  // the specified operation. It must not be used if the caller cannot be
  // identified (Unauthenticated).
  static HttpErr PermissionDenied = HttpErr('permission denied', 403);
  // Unauthenticated indicates the request does not have valid authentication
  // credentials for the operation. Unauthorized.
  static HttpErr Unauthenticated = HttpErr('unauthenticated', 401);
  // ResourceExhausted indicates some resource has been exhausted, perhaps a
  // per-user quota, or perhaps the entire file system is out of space. Forbidden.
  static HttpErr ResourceExhausted = HttpErr('resource exhausted', 403);
  // FailedPrecondition indicates operation was rejected because the system is
  // not in a state required for the operation's execution. For example, doing
  // an rmdir operation on a directory that is non-empty, or on a non-directory
  // object, or when having conflicting read-modify-write on the same resource. Precondition failed.
  static HttpErr FailedPrecondition = HttpErr('failed precondition', 412);
  // Aborted indicates the operation was aborted, typically due to a concurrency
  // issue like sequencer check failures, transaction aborts, etc.
  static HttpErr Aborted = HttpErr('aborted', 409);
  // OutOfRange means operation was attempted past the valid range. For example,
  // seeking or reading past end of a paginated collection.
  //
  // Unlike InvalidArgument, this error indicates a problem that may be fixed if
  // the system state changes (i.e. adding more items to the collection).
  //
  // There is a fair bit of overlap between FailedPrecondition and OutOfRange.
  // We recommend using OutOfRange (the more specific error) when it applies so
  // that callers who are iterating through a space can easily look for an
  // OutOfRange error to detect when they are done.
  static HttpErr OutOfRange = HttpErr('out of range', 400);
  // Unimplemented indicates operation is not implemented or not
  // supported/enabled in this service.
  static HttpErr Unimplemented = HttpErr('unimplemented', 501);
  // Internal errors. When some invariants expected by the underlying system
  // have been broken. In other words, something bad happened in the library or
  // backend service. Do not confuse with HTTP Internal Server Error; an
  // Internal error could also happen on the client code, i.e. when parsing a
  // server response.
  static HttpErr Internal = HttpErr('internal', 500);
  // Unavailable indicates the service is currently unavailable. This is a most
  // likely a transient condition and may be corrected by retrying with a
  // backoff. Service Unavailable.
  static HttpErr Unavailable = HttpErr('unavailable', 503);
  // DataLoss indicates unrecoverable data loss or corruption.
  static HttpErr DataLoss = HttpErr('data loss', 500);
}
