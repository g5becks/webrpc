import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:http/http.dart' as http;
import 'package:meta/meta.dart';

part 'example_service.freezed.dart';
part 'example_service.g.dart';

// example v0.0.1 297cedbc91660c3155f254892772490bc0522641
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/dart
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
String webRPCVersion() {
  return "v1";
}

// Schema version of your RIDL schema
String WebRPCSchemaVersion() {
  return "v0.0.1";
}

// Schema hash generated from your RIDL schema
String WebRPCSchemaHash() {
  return "297cedbc91660c3155f254892772490bc0522641";
}

// **********************************************************************
// MESSAGE TYPES.
// **********************************************************************
@freezed
abstract class Kind with _$Kind {
  const factory Kind.user() = USER;
  const factory Kind.admin() = ADMIN;
  factory Kind.fromJson(Map<String, dynamic> json) => _$KindFromJson(json);
}

@freezed
abstract class Empty with _$Empty {
  factory Empty() = _Empty;
  factory Empty.fromJson(Map<String, dynamic> json) => _$EmptyFromJson(json);
}

@freezed
abstract class User with _$User {
  factory User({
    @required int id,
    @JsonKey(name: 'USERNAME') @required String username,
    @required String role,
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

@freezed
abstract class SearchFilter with _$SearchFilter {
  factory SearchFilter({
    @required String q,
  }) = _SearchFilter;
  factory SearchFilter.fromJson(Map<String, dynamic> json) =>
      _$SearchFilterFromJson(json);
}

@freezed
abstract class Version with _$Version {
  factory Version({
    @required String webrpcVersion,
    @required String schemaVersion,
    @required String schemaHash,
  }) = _Version;
  factory Version.fromJson(Map<String, dynamic> json) =>
      _$VersionFromJson(json);
}

@freezed
abstract class ComplexType with _$ComplexType {
  factory ComplexType({
    @required Map<String, dynamic> meta,
    @required Map<String, Map<String, int>> metaNestedExample,
    @required List<String> namesList,
    @required List<int> numsList,
    @required List<List<String>> doubleArray,
    @required List<User> listOfUsers,
    @required Map<String, User> mapOfUsers,
    @required User user,
    List<Map<String, int>> listOfMaps,
  }) = _ComplexType;
  factory ComplexType.fromJson(Map<String, dynamic> json) =>
      _$ComplexTypeFromJson(json);
}

// *********************************************************************
// ExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class _ExampleServiceGetUserArgs with _$_ExampleServiceGetUserArgs {
  factory _ExampleServiceGetUserArgs({
    @required Map<String, String> header,
    @required int userID,
  }) = _ExampleServiceGetUserArgs_Freezed;
  factory _ExampleServiceGetUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_ExampleServiceGetUserArgsFromJson(json);
}

@freezed
abstract class _ExampleServiceFindUserArgs with _$_ExampleServiceFindUserArgs {
  factory _ExampleServiceFindUserArgs({
    @required SearchFilter s,
  }) = _ExampleServiceFindUserArgs_Freezed;
  factory _ExampleServiceFindUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_ExampleServiceFindUserArgsFromJson(json);
}

// *********************************************************************
// ExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class StatusResponse with _$StatusResponse {
  factory StatusResponse({
    @required bool status,
  }) = _StatusResponse;

  factory StatusResponse.rpcErr({
    @required String message,
    @required String route,
    @required int statusCode,
    @required DateTime timeStamp,
  }) = _StatusResponseRpcErr;

  factory StatusResponse.fromJson(Map<String, dynamic> json) =>
      _$StatusResponseFromJson(json);
}

@freezed
abstract class VersionResponse with _$VersionResponse {
  factory VersionResponse({
    @required Version version,
  }) = _VersionResponse;

  factory VersionResponse.rpcErr({
    @required String message,
    @required String route,
    @required int statusCode,
    @required DateTime timeStamp,
  }) = _VersionResponseRpcErr;

  factory VersionResponse.fromJson(Map<String, dynamic> json) =>
      _$VersionResponseFromJson(json);
}

@freezed
abstract class GetUserResponse with _$GetUserResponse {
  factory GetUserResponse({
    @required int code,
    @required User user,
  }) = _GetUserResponse;

  factory GetUserResponse.rpcErr({
    @required String message,
    @required String route,
    @required int statusCode,
    @required DateTime timeStamp,
  }) = _GetUserResponseRpcErr;

  factory GetUserResponse.fromJson(Map<String, dynamic> json) =>
      _$GetUserResponseFromJson(json);
}

@freezed
abstract class FindUserResponse with _$FindUserResponse {
  factory FindUserResponse({
    @required String name,
    @required User user,
  }) = _FindUserResponse;

  factory FindUserResponse.rpcErr({
    @required String message,
    @required String route,
    @required int statusCode,
    @required DateTime timeStamp,
  }) = _FindUserResponseRpcErr;

  factory FindUserResponse.fromJson(Map<String, dynamic> json) =>
      _$FindUserResponseFromJson(json);
}

// *********************************************************************
// AnotherExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class _AnotherExampleServiceGetAccountArgs
    with _$_AnotherExampleServiceGetAccountArgs {
  factory _AnotherExampleServiceGetAccountArgs({
    @required Map<String, String> header,
    @required int userID,
  }) = _AnotherExampleServiceGetAccountArgs_Freezed;
  factory _AnotherExampleServiceGetAccountArgs.fromJson(
          Map<String, dynamic> json) =>
      _$_AnotherExampleServiceGetAccountArgsFromJson(json);
}

@freezed
abstract class _AnotherExampleServiceGetUsersArgs
    with _$_AnotherExampleServiceGetUsersArgs {
  factory _AnotherExampleServiceGetUsersArgs({
    @required SearchFilter s,
  }) = _AnotherExampleServiceGetUsersArgs_Freezed;
  factory _AnotherExampleServiceGetUsersArgs.fromJson(
          Map<String, dynamic> json) =>
      _$_AnotherExampleServiceGetUsersArgsFromJson(json);
}

// *********************************************************************
// AnotherExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class AnotherExampleServiceStatusResponse
    with _$AnotherExampleServiceStatusResponse {
  factory AnotherExampleServiceStatusResponse({
    @required bool status,
  }) = _AnotherExampleServiceStatusResponse;

  factory AnotherExampleServiceStatusResponse.rpcErr({
    @required String message,
    @required String route,
    @required int statusCode,
    @required DateTime timeStamp,
  }) = _AnotherExampleServiceStatusResponseRpcErr;

  factory AnotherExampleServiceStatusResponse.fromJson(
          Map<String, dynamic> json) =>
      _$AnotherExampleServiceStatusResponseFromJson(json);
}

@freezed
abstract class GetVersionResponse with _$GetVersionResponse {
  factory GetVersionResponse({
    @required Version version,
  }) = _GetVersionResponse;

  factory GetVersionResponse.rpcErr({
    @required String message,
    @required String route,
    @required int statusCode,
    @required DateTime timeStamp,
  }) = _GetVersionResponseRpcErr;

  factory GetVersionResponse.fromJson(Map<String, dynamic> json) =>
      _$GetVersionResponseFromJson(json);
}

@freezed
abstract class GetAccountResponse with _$GetAccountResponse {
  factory GetAccountResponse({
    @required int code,
    @required User user,
  }) = _GetAccountResponse;

  factory GetAccountResponse.rpcErr({
    @required String message,
    @required String route,
    @required int statusCode,
    @required DateTime timeStamp,
  }) = _GetAccountResponseRpcErr;

  factory GetAccountResponse.fromJson(Map<String, dynamic> json) =>
      _$GetAccountResponseFromJson(json);
}

@freezed
abstract class GetUsersResponse with _$GetUsersResponse {
  factory GetUsersResponse({
    @required String name,
    @required User user,
  }) = _GetUsersResponse;

  factory GetUsersResponse.rpcErr({
    @required String message,
    @required String route,
    @required int statusCode,
    @required DateTime timeStamp,
  }) = _GetUsersResponseRpcErr;

  factory GetUsersResponse.fromJson(Map<String, dynamic> json) =>
      _$GetUsersResponseFromJson(json);
}

// ***********************************************************************
// WEBRPC-DART SERVICE CLIENTS.
// ***********************************************************************

String _removeSlash(String host) => host.endsWith('/')
    ? host.replaceRange(host.length - 1, host.length, '')
    : host;

class ExampleService {
  final String host;
  RpcLogger _log;
  String _srvcPath = '/rpc/ExampleService/';
  ExampleService({
    this.host = 'localhost',
    RpcLogger logger,
  }) {
    _srvcPath = '${_removeSlash(host)}/rpc/ExampleService/';
    _log = logger ?? _rpcLogger;
  }

  Future<http.Response> _makeRequest(
    String route, {
    dynamic json = "{}",
    Map<String, String> headers,
  }) {
    final path = '$_srvcPath/$route';
    _log.info('{"info": request to $path made at ${DateTime.now()}}');
    return http.post(path,
        headers: {
          ...?headers,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: json);
  }

  RpcErr _getErr(http.Response r) {
    try {
      return RpcErr.fromJson(jsonDecode(r.body));
    } on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<void> ping({
    Map<String, String> headers,
  }) async {
    try {} on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<StatusResponse> status({
    Map<String, String> headers,
  }) async {
    try {} on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<VersionResponse> version({
    Map<String, String> headers,
  }) async {
    try {} on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<GetUserResponse> getUser({
    @required Map<String, String> header,
    @required int userID,
    Map<String, String> headers,
  }) async {
    try {
      final _ExampleServiceGetUserArgs args = _ExampleServiceGetUserArgs(
        header: header,
        userID: userID,
      );
      final http.Response response = await _makeRequest(
        '',
        json: jsonEncode(args.toJson()),
        headers: headers,
      );
      if (!nonErrorcodes.contains(response.statusCode)) {
        final RpcErr err = _getErr(response);
        return GetUserResponse.rpcErr(
          message: err.message,
          route: err.path,
          statusCode: err.httpErr.code,
          timeStamp: err.time,
        );
      }
      return GetUserResponse.fromJson(
        jsonDecode(
          response.body,
        ),
      );
    } on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<FindUserResponse> findUser({
    @required SearchFilter s,
    Map<String, String> headers,
  }) async {
    try {
      final _ExampleServiceFindUserArgs args = _ExampleServiceFindUserArgs(
        s: s,
      );
      final http.Response response = await _makeRequest(
        '',
        json: jsonEncode(args.toJson()),
        headers: headers,
      );
      if (!nonErrorcodes.contains(response.statusCode)) {
        final RpcErr err = _getErr(response);
        return FindUserResponse.rpcErr(
          message: err.message,
          route: err.path,
          statusCode: err.httpErr.code,
          timeStamp: err.time,
        );
      }
      return FindUserResponse.fromJson(
        jsonDecode(
          response.body,
        ),
      );
    } on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }
}

class AnotherExampleService {
  final String host;
  RpcLogger _log;
  String _srvcPath = '/rpc/AnotherExampleService/';
  AnotherExampleService({
    this.host = 'localhost',
    RpcLogger logger,
  }) {
    _srvcPath = '${_removeSlash(host)}/rpc/AnotherExampleService/';
    _log = logger ?? _rpcLogger;
  }

  Future<http.Response> _makeRequest(
    String route, {
    dynamic json = "{}",
    Map<String, String> headers,
  }) {
    final path = '$_srvcPath/$route';
    _log.info('{"info": request to $path made at ${DateTime.now()}}');
    return http.post(path,
        headers: {
          ...?headers,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: json);
  }

  RpcErr _getErr(http.Response r) {
    try {
      return RpcErr.fromJson(jsonDecode(r.body));
    } on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<void> pingServer({
    Map<String, String> headers,
  }) async {
    try {} on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<AnotherExampleServiceStatusResponse> status({
    Map<String, String> headers,
  }) async {
    try {} on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<GetVersionResponse> getVersion({
    Map<String, String> headers,
  }) async {
    try {} on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<GetAccountResponse> getAccount({
    @required Map<String, String> header,
    @required int userID,
    Map<String, String> headers,
  }) async {
    try {
      final _AnotherExampleServiceGetAccountArgs args =
          _AnotherExampleServiceGetAccountArgs(
        header: header,
        userID: userID,
      );
      final http.Response response = await _makeRequest(
        '',
        json: jsonEncode(args.toJson()),
        headers: headers,
      );
      if (!nonErrorcodes.contains(response.statusCode)) {
        final RpcErr err = _getErr(response);
        return GetAccountResponse.rpcErr(
          message: err.message,
          route: err.path,
          statusCode: err.httpErr.code,
          timeStamp: err.time,
        );
      }
      return GetAccountResponse.fromJson(
        jsonDecode(
          response.body,
        ),
      );
    } on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }

  FutureOr<GetUsersResponse> getUsers({
    @required SearchFilter s,
    Map<String, String> headers,
  }) async {
    try {
      final _AnotherExampleServiceGetUsersArgs args =
          _AnotherExampleServiceGetUsersArgs(
        s: s,
      );
      final http.Response response = await _makeRequest(
        '',
        json: jsonEncode(args.toJson()),
        headers: headers,
      );
      if (!nonErrorcodes.contains(response.statusCode)) {
        final RpcErr err = _getErr(response);
        return GetUsersResponse.rpcErr(
          message: err.message,
          route: err.path,
          statusCode: err.httpErr.code,
          timeStamp: err.time,
        );
      }
      return GetUsersResponse.fromJson(
        jsonDecode(
          response.body,
        ),
      );
    } on Exception catch (e, stackTrace) {
      _logExc(_log, e, null, stackTrace);
    }
  }
}

// *********************************************************************
// WEBRPC-DART HELPER CODE.
// *********************************************************************

const Set<int> nonErrorcodes = {
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  300,
  301,
  302,
  303,
  304,
  307,
  308,
};

String _logMsg(
  Exception exc, [
  Object error,
  StackTrace stackTrace,
]) =>
    '{message: ${exc.toString()}, timeStamp: ${DateTime.now().toString()}, error: $error, stackTrace: $stackTrace}';

void _logExc(
  RpcLogger log,
  Exception exc, [
  Object error,
  StackTrace stackTrace,
]) =>
    log.warning(_logMsg(exc, error, stackTrace));

abstract class RpcLogger {
  void _log(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      print(
          '{message: $message}, error: $error, stackTrace: $stackTrace, time: ${DateTime.now()}');
  void finest(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void finer(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void fine(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void config(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void info(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void warning(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void severe(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
  void shout(
    String message, [
    Object error,
    StackTrace stackTrace,
  ]) =>
      _log(message, error, stackTrace);
}

class _Logger extends RpcLogger {
  _Logger();
}

final _rpcLogger = _Logger();

// An http error.
class HttpErr {
  final String status;
  final int code;
  const HttpErr(this.status, this.code);

  Map<String, dynamic> toMap() => {'status': status, 'code': code};
  String toJson() => jsonEncode(toMap());
  static HttpErr fromMap(Map<String, dynamic> map) =>
      HttpErr(map['status'] as String, map['code'] as int);

  static HttpErr fromJson(json) => fromMap(jsonDecode(json));
}

// An error created by the rpc server.
class RpcErr {
  final String message;
  final String path;
  final DateTime time;
  final HttpErr httpErr;
  const RpcErr({this.message, this.path, this.httpErr, this.time});

  Map<String, dynamic> toMap() => {
        'message': message,
        'path': path,
        'httpErr': httpErr.toMap(),
        'time-stamp': time.toString()
      };
  String toJson() => jsonEncode(toMap());
  static RpcErr fromMap(Map<String, dynamic> map) => RpcErr(
      message: map['message'] as String,
      path: map['path'] as String,
      time: DateTime.parse(map['time-stamp']),
      httpErr: HttpErr.fromMap(map['httpErr']));
  static RpcErr fromJson(json) => fromMap(jsonDecode(json));
}

// Contains static fields for creating and identifying http errors.
class err {
  // Unknown error. For example when handling errors raised by APIs that do not
  // return enough error information.
  static const HttpErr Unknown = HttpErr('unknown', 400);
  // 422 (Unprocessable Entity) Fail error. General failure error type.
  static const HttpErr Fail = HttpErr('fail', 422);
  // RequestTimeout Canceled indicates the operation was cancelled (typically by the caller).
  static const HttpErr Canceled = HttpErr('canceled', 408);
  // InvalidArgument indicates client specified an invalid argument. It
  // indicates arguments that are problematic regardless of the state of the
  // system (i.e. a malformed file name, required argument, number out of range,
  // etc.).
  static const HttpErr InvalidArgument = HttpErr('invalid argument', 422);
  // RequestTimeOut. DeadlineExceeded means operation expired before completion. For operations
  // that change the state of the system, this error may be returned even if the
  // operation has completed successfully (timeout).
  static const HttpErr DeadlineExceeded = HttpErr('deadline exceeded', 408);
  // NotFound means some requested entity was not found.
  static const HttpErr NotFound = HttpErr('not found', 404);
  // BadRoute means that the requested URL path wasn't routable to a webrpc
  // service and method. This is returned by the generated server, and usually
  // shouldn't be returned by applications. Instead, applications should use
  // NotFound or Unimplemented.
  static const HttpErr BadRoute = HttpErr('bad route', 404);
  // AlreadyExists means an attempt to create an entity failed because one
  // already exists. Conflict.
  static const HttpErr AlreadyExists = HttpErr('already exists', 409);
  // PermissionDenied indicates the caller does not have permission to execute
  // the specified operation. It must not be used if the caller cannot be
  // identified (Unauthenticated).
  static const HttpErr PermissionDenied = HttpErr('permission denied', 403);
  // Unauthenticated indicates the request does not have valid authentication
  // credentials for the operation. Unauthorized.
  static const HttpErr Unauthenticated = HttpErr('unauthenticated', 401);
  // ResourceExhausted indicates some resource has been exhausted, perhaps a
  // per-user quota, or perhaps the entire file system is out of space. Forbidden.
  static const HttpErr ResourceExhausted = HttpErr('resource exhausted', 403);
  // FailedPrecondition indicates operation was rejected because the system is
  // not in a state required for the operation's execution. For example, doing
  // an rmdir operation on a directory that is non-empty, or on a non-directory
  // object, or when having conflicting read-modify-write on the same resource. Precondition failed.
  static const HttpErr FailedPrecondition = HttpErr('failed precondition', 412);
  // Aborted indicates the operation was aborted, typically due to a concurrency
  // issue like sequencer check failures, transaction aborts, etc.
  static const HttpErr Aborted = HttpErr('aborted', 409);
  // OutOfRange means operation was attempted past the valid range. For example,
  // seeking or reading past end of a paginated collection.
  //
  // Unlike InvalidArgument, this error indicates a problem that may be fixed if
  // the system state changes (i.e. adding more items to the collection).
  //
  // There is a fair bit of overlap between FailedPrecondition and OutOfRange.
  // We recommend using OutOfRange (the more specific error) when it applies so
  // that callers who are iterating through a space can easily look for an
  // OutOfRange error to detect when they are done.
  static const HttpErr OutOfRange = HttpErr('out of range', 400);
  // Unimplemented indicates operation is not implemented or not
  // supported/enabled in this service.
  static const HttpErr Unimplemented = HttpErr('unimplemented', 501);
  // Internal errors. When some invariants expected by the underlying system
  // have been broken. In other words, something bad happened in the library or
  // backend service. Do not confuse with HTTP Internal Server Error; an
  // Internal error could also happen on the client code, i.e. when parsing a
  // server response.
  static const HttpErr Internal = HttpErr('internal', 500);
  // Unavailable indicates the service is currently unavailable. This is a most
  // likely a transient condition and may be corrected by retrying with a
  // backoff. Service Unavailable.
  static const HttpErr Unavailable = HttpErr('unavailable', 503);
  // DataLoss indicates unrecoverable data loss or corruption.
  static const HttpErr DataLoss = HttpErr('data loss', 500);
}
